const g = [
  "Aztec",
  "Codabar",
  "Code128",
  "Code39",
  "Code93",
  "DataBar",
  "DataBarExpanded",
  "DataMatrix",
  "DXFilmEdge",
  "EAN-13",
  "EAN-8",
  "ITF",
  "Linear-Codes",
  "Matrix-Codes",
  "MaxiCode",
  "MicroQRCode",
  "None",
  "PDF417",
  "QRCode",
  "rMQRCode",
  "UPC-A",
  "UPC-E"
];
function O(e) {
  return e.join("|");
}
function b(e) {
  const t = E(e);
  let r = 0, o = g.length - 1;
  for (; r <= o; ) {
    const n = Math.floor((r + o) / 2), a = g[n], s = E(a);
    if (s === t)
      return a;
    s < t ? r = n + 1 : o = n - 1;
  }
  return "None";
}
function E(e) {
  return e.toLowerCase().replace(/_-\[\]/g, "");
}
const v = [
  "LocalAverage",
  "GlobalHistogram",
  "FixedThreshold",
  "BoolCast"
];
function w(e, t) {
  return e.Binarizer[t];
}
const P = [
  "Unknown",
  "ASCII",
  "ISO8859_1",
  "ISO8859_2",
  "ISO8859_3",
  "ISO8859_4",
  "ISO8859_5",
  "ISO8859_6",
  "ISO8859_7",
  "ISO8859_8",
  "ISO8859_9",
  "ISO8859_10",
  "ISO8859_11",
  "ISO8859_13",
  "ISO8859_14",
  "ISO8859_15",
  "ISO8859_16",
  "Cp437",
  "Cp1250",
  "Cp1251",
  "Cp1252",
  "Cp1256",
  "Shift_JIS",
  "Big5",
  "GB2312",
  "GB18030",
  "EUC_JP",
  "EUC_KR",
  "UTF16BE",
  "UTF8",
  "UTF16LE",
  "UTF32BE",
  "UTF32LE",
  "BINARY"
];
function I(e, t) {
  return e.CharacterSet[t];
}
const F = [
  "Text",
  "Binary",
  "Mixed",
  "GS1",
  "ISO15434",
  "UnknownECI"
];
function _(e) {
  return F[e.value];
}
const L = ["Ignore", "Read", "Require"];
function p(e, t) {
  return e.EanAddOnSymbol[t];
}
const M = ["Plain", "ECI", "HRI", "Hex", "Escaped"];
function B(e, t) {
  return e.TextMode[t];
}
const u = {
  formats: [],
  tryHarder: !0,
  tryRotate: !0,
  tryInvert: !0,
  tryDownscale: !0,
  binarizer: "LocalAverage",
  isPure: !1,
  downscaleFactor: 3,
  downscaleThreshold: 500,
  minLineCount: 2,
  maxNumberOfSymbols: 255,
  tryCode39ExtendedMode: !1,
  validateCode39CheckSum: !1,
  validateITFCheckSum: !1,
  returnCodabarStartEnd: !1,
  returnErrors: !1,
  eanAddOnSymbol: "Read",
  textMode: "Plain",
  characterSet: "Unknown"
};
function y(e, t) {
  return {
    ...t,
    formats: O(t.formats),
    binarizer: w(e, t.binarizer),
    eanAddOnSymbol: p(
      e,
      t.eanAddOnSymbol
    ),
    textMode: B(e, t.textMode),
    characterSet: I(
      e,
      t.characterSet
    )
  };
}
const x = [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8], D = ["L", "M", "Q", "H"], S = {
  width: 200,
  height: 200,
  format: "QRCode",
  characterSet: "UTF8",
  eccLevel: -1,
  margin: 10
};
function A(e, t) {
  return {
    ...t,
    characterSet: I(
      e,
      t.characterSet
    )
  };
}
function T(e) {
  return {
    ...e,
    format: b(e.format),
    eccLevel: e.eccLevel,
    contentType: _(e.contentType)
  };
}
function R(e) {
  const { image: t, error: r } = e;
  return t ? {
    image: new Blob([new Uint8Array(t)], {
      type: "image/png"
    }),
    error: ""
  } : {
    image: null,
    error: r
  };
}
const U = {
  locateFile: (e, t) => {
    const r = e.match(/_(.+?)\.wasm$/);
    return r ? `https://fastly.jsdelivr.net/npm/zxing-wasm@1.1.1/dist/${r[1]}/${e}` : t + e;
  }
};
let m = /* @__PURE__ */ new WeakMap();
function h(e, t) {
  var a;
  const r = m.get(e);
  if (r != null && r.modulePromise && (t === void 0 || Object.is(t, r.moduleOverrides)))
    return r.modulePromise;
  const o = (a = t != null ? t : r == null ? void 0 : r.moduleOverrides) != null ? a : U, n = e({
    ...o
  });
  return m.set(e, {
    moduleOverrides: o,
    modulePromise: n
  }), n;
}
function H() {
  m = /* @__PURE__ */ new WeakMap();
}
function X(e, t) {
  m.set(e, {
    moduleOverrides: t
  });
}
async function Z(e, t, r = u) {
  const o = {
    ...u,
    ...r
  }, n = await h(e), { size: a } = t, s = new Uint8Array(await t.arrayBuffer()), d = n._malloc(a);
  n.HEAPU8.set(s, d);
  const l = n.readBarcodesFromImage(
    d,
    a,
    y(n, o)
  );
  n._free(d);
  const c = [];
  for (let i = 0; i < l.size(); ++i)
    c.push(
      T(l.get(i))
    );
  return c;
}
async function z(e, t, r = u) {
  const o = {
    ...u,
    ...r
  }, n = await h(e), {
    data: a,
    width: s,
    height: d,
    data: { byteLength: l }
  } = t, c = n._malloc(l);
  n.HEAPU8.set(a, c);
  const i = n.readBarcodesFromPixmap(
    c,
    s,
    d,
    y(n, o)
  );
  n._free(c);
  const C = [];
  for (let f = 0; f < i.size(); ++f)
    C.push(
      T(i.get(f))
    );
  return C;
}
async function W(e, t, r = S) {
  const o = {
    ...S,
    ...r
  }, n = await h(e), a = n.writeBarcodeToImage(
    t,
    A(n, o)
  );
  return R(a);
}
const k = structuredClone(u), N = structuredClone(S);
export {
  z as a,
  g as b,
  v as c,
  k as d,
  P as e,
  F as f,
  h as g,
  L as h,
  D as i,
  N as j,
  x as k,
  H as p,
  Z as r,
  X as s,
  M as t,
  W as w
};
