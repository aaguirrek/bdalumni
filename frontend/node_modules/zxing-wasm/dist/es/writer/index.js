import { g as Ht, s as Ot, w as Mt } from "../core-S1nn-RrW.js";
import { b as Gt, e as Kt, j as Jt, p as Qt, k as Yt } from "../core-S1nn-RrW.js";
var dr = (() => {
  var k = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
  return function(K = {}) {
    var s = K, hr, J;
    s.ready = new Promise((r, e) => {
      hr = r, J = e;
    });
    var _r = Object.assign({}, s), pr = typeof window == "object", Q = typeof importScripts == "function";
    typeof process == "object" && typeof process.versions == "object" && process.versions.node;
    var C = "";
    function Qr(r) {
      return s.locateFile ? s.locateFile(r, C) : C + r;
    }
    var or;
    (pr || Q) && (Q ? C = self.location.href : typeof document < "u" && document.currentScript && (C = document.currentScript.src), k && (C = k), C.indexOf("blob:") !== 0 ? C = C.substr(0, C.replace(/[?#].*/, "").lastIndexOf("/") + 1) : C = "", Q && (or = (r) => {
      var e = new XMLHttpRequest();
      return e.open("GET", r, !1), e.responseType = "arraybuffer", e.send(null), new Uint8Array(e.response);
    })), s.print || console.log.bind(console);
    var L = s.printErr || console.error.bind(console);
    Object.assign(s, _r), _r = null, s.arguments && s.arguments, s.thisProgram && s.thisProgram, s.quit && s.quit;
    var N;
    s.wasmBinary && (N = s.wasmBinary), typeof WebAssembly != "object" && rr("no native wasm support detected");
    var Y, gr = !1;
    function Yr(r, e) {
      r || rr(e);
    }
    var S, g, H, X, U, d, yr, mr;
    function br() {
      var r = Y.buffer;
      s.HEAP8 = S = new Int8Array(r), s.HEAP16 = H = new Int16Array(r), s.HEAPU8 = g = new Uint8Array(r), s.HEAPU16 = X = new Uint16Array(r), s.HEAP32 = U = new Int32Array(r), s.HEAPU32 = d = new Uint32Array(r), s.HEAPF32 = yr = new Float32Array(r), s.HEAPF64 = mr = new Float64Array(r);
    }
    var wr = [], Tr = [], $r = [];
    function re() {
      if (s.preRun)
        for (typeof s.preRun == "function" && (s.preRun = [s.preRun]); s.preRun.length; )
          ne(s.preRun.shift());
      sr(wr);
    }
    function ee() {
      sr(Tr);
    }
    function te() {
      if (s.postRun)
        for (typeof s.postRun == "function" && (s.postRun = [s.postRun]); s.postRun.length; )
          ae(s.postRun.shift());
      sr($r);
    }
    function ne(r) {
      wr.unshift(r);
    }
    function ie(r) {
      Tr.unshift(r);
    }
    function ae(r) {
      $r.unshift(r);
    }
    var j = 0, Z = null;
    function oe(r) {
      j++, s.monitorRunDependencies && s.monitorRunDependencies(j);
    }
    function se(r) {
      if (j--, s.monitorRunDependencies && s.monitorRunDependencies(j), j == 0 && Z) {
        var e = Z;
        Z = null, e();
      }
    }
    function rr(r) {
      s.onAbort && s.onAbort(r), r = "Aborted(" + r + ")", L(r), gr = !0, r += ". Build with -sASSERTIONS for more info.";
      var e = new WebAssembly.RuntimeError(r);
      throw J(e), e;
    }
    var fe = "data:application/octet-stream;base64,", Ar = (r) => r.startsWith(fe), O;
    O = "zxing_writer.wasm", Ar(O) || (O = Qr(O));
    function Er(r) {
      if (r == O && N)
        return new Uint8Array(N);
      if (or)
        return or(r);
      throw "both async and sync fetching of the wasm failed";
    }
    function ue(r) {
      return !N && (pr || Q) && typeof fetch == "function" ? fetch(r, { credentials: "same-origin" }).then((e) => {
        if (!e.ok)
          throw "failed to load wasm binary file at '" + r + "'";
        return e.arrayBuffer();
      }).catch(() => Er(r)) : Promise.resolve().then(() => Er(r));
    }
    function Cr(r, e, t) {
      return ue(r).then((n) => WebAssembly.instantiate(n, e)).then((n) => n).then(t, (n) => {
        L(`failed to asynchronously prepare wasm: ${n}`), rr(n);
      });
    }
    function ce(r, e, t, n) {
      return !r && typeof WebAssembly.instantiateStreaming == "function" && !Ar(e) && typeof fetch == "function" ? fetch(e, { credentials: "same-origin" }).then((i) => {
        var a = WebAssembly.instantiateStreaming(i, t);
        return a.then(n, function(o) {
          return L(`wasm streaming compile failed: ${o}`), L("falling back to ArrayBuffer instantiation"), Cr(e, t, n);
        });
      }) : Cr(e, t, n);
    }
    function le() {
      var r = { a: Et };
      function e(n, i) {
        return h = n.exports, Y = h.P, br(), Mr = h.T, ie(h.Q), se(), h;
      }
      oe();
      function t(n) {
        e(n.instance);
      }
      if (s.instantiateWasm)
        try {
          return s.instantiateWasm(r, e);
        } catch (n) {
          L(`Module.instantiateWasm callback failed with error: ${n}`), J(n);
        }
      return ce(N, O, r, t).catch(J), {};
    }
    var sr = (r) => {
      for (; r.length > 0; )
        r.shift()(s);
    };
    s.noExitRuntime;
    var Rr = [], ve = (r) => {
      var e = new fr(r);
      return e.get_caught() || e.set_caught(!0), e.set_rethrown(!1), Rr.push(e), zr(e.excPtr), e.get_exception_ptr();
    }, x = 0, de = () => {
      b(0, 0);
      var r = Rr.pop();
      qr(r.excPtr), x = 0;
    };
    function fr(r) {
      this.excPtr = r, this.ptr = r - 24, this.set_type = function(e) {
        d[this.ptr + 4 >> 2] = e;
      }, this.get_type = function() {
        return d[this.ptr + 4 >> 2];
      }, this.set_destructor = function(e) {
        d[this.ptr + 8 >> 2] = e;
      }, this.get_destructor = function() {
        return d[this.ptr + 8 >> 2];
      }, this.set_caught = function(e) {
        e = e ? 1 : 0, S[this.ptr + 12 >> 0] = e;
      }, this.get_caught = function() {
        return S[this.ptr + 12 >> 0] != 0;
      }, this.set_rethrown = function(e) {
        e = e ? 1 : 0, S[this.ptr + 13 >> 0] = e;
      }, this.get_rethrown = function() {
        return S[this.ptr + 13 >> 0] != 0;
      }, this.init = function(e, t) {
        this.set_adjusted_ptr(0), this.set_type(e), this.set_destructor(t);
      }, this.set_adjusted_ptr = function(e) {
        d[this.ptr + 16 >> 2] = e;
      }, this.get_adjusted_ptr = function() {
        return d[this.ptr + 16 >> 2];
      }, this.get_exception_ptr = function() {
        var e = Kr(this.get_type());
        if (e)
          return d[this.excPtr >> 2];
        var t = this.get_adjusted_ptr();
        return t !== 0 ? t : this.excPtr;
      };
    }
    var he = (r) => {
      throw x || (x = r), x;
    }, ur = (r) => {
      var e = x;
      if (!e)
        return z(0), 0;
      var t = new fr(e);
      t.set_adjusted_ptr(e);
      var n = t.get_type();
      if (!n)
        return z(0), e;
      for (var i in r) {
        var a = r[i];
        if (a === 0 || a === n)
          break;
        var o = t.ptr + 16;
        if (Gr(a, n, o))
          return z(a), e;
      }
      return z(n), e;
    }, _e = () => ur([]), pe = (r) => ur([r]), ge = (r, e) => ur([r, e]), ye = (r, e, t) => {
      var n = new fr(r);
      throw n.init(e, t), x = r, x;
    }, er = {}, Pr = (r) => {
      for (; r.length; ) {
        var e = r.pop(), t = r.pop();
        t(e);
      }
    };
    function cr(r) {
      return this.fromWireType(U[r >> 2]);
    }
    var M = {}, D = {}, tr = {}, Fr, Wr = (r) => {
      throw new Fr(r);
    }, kr = (r, e, t) => {
      r.forEach(function(f) {
        tr[f] = e;
      });
      function n(f) {
        var u = t(f);
        u.length !== r.length && Wr("Mismatched type converter count");
        for (var c = 0; c < r.length; ++c)
          R(r[c], u[c]);
      }
      var i = new Array(e.length), a = [], o = 0;
      e.forEach((f, u) => {
        D.hasOwnProperty(f) ? i[u] = D[f] : (a.push(f), M.hasOwnProperty(f) || (M[f] = []), M[f].push(() => {
          i[u] = D[f], ++o, o === a.length && n(i);
        }));
      }), a.length === 0 && n(i);
    }, me = (r) => {
      var e = er[r];
      delete er[r];
      var t = e.rawConstructor, n = e.rawDestructor, i = e.fields, a = i.map((o) => o.getterReturnType).concat(i.map((o) => o.setterArgumentType));
      kr([r], a, (o) => {
        var f = {};
        return i.forEach((u, c) => {
          var v = u.fieldName, l = o[c], p = u.getter, A = u.getterContext, P = o[c + i.length], I = u.setter, E = u.setterContext;
          f[v] = { read: (G) => l.fromWireType(p(A, G)), write: (G, vr) => {
            var ar = [];
            I(E, G, P.toWireType(ar, vr)), Pr(ar);
          } };
        }), [{ name: e.name, fromWireType: (u) => {
          var c = {};
          for (var v in f)
            c[v] = f[v].read(u);
          return n(u), c;
        }, toWireType: (u, c) => {
          for (var v in f)
            if (!(v in c))
              throw new TypeError(`Missing field: "${v}"`);
          var l = t();
          for (v in f)
            f[v].write(l, c[v]);
          return u !== null && u.push(n, l), l;
        }, argPackAdvance: F, readValueFromPointer: cr, destructorFunction: n }];
      });
    }, be = (r, e, t, n, i) => {
    }, we = () => {
      for (var r = new Array(256), e = 0; e < 256; ++e)
        r[e] = String.fromCharCode(e);
      Sr = r;
    }, Sr, _ = (r) => {
      for (var e = "", t = r; g[t]; )
        e += Sr[g[t++]];
      return e;
    }, Ur, y = (r) => {
      throw new Ur(r);
    };
    function Te(r, e, t = {}) {
      var n = e.name;
      if (r || y(`type "${n}" must have a positive integer typeid pointer`), D.hasOwnProperty(r)) {
        if (t.ignoreDuplicateRegistrations)
          return;
        y(`Cannot register type '${n}' twice`);
      }
      if (D[r] = e, delete tr[r], M.hasOwnProperty(r)) {
        var i = M[r];
        delete M[r], i.forEach((a) => a());
      }
    }
    function R(r, e, t = {}) {
      if (!("argPackAdvance" in e))
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      return Te(r, e, t);
    }
    var F = 8, $e = (r, e, t, n) => {
      e = _(e), R(r, { name: e, fromWireType: function(i) {
        return !!i;
      }, toWireType: function(i, a) {
        return a ? t : n;
      }, argPackAdvance: F, readValueFromPointer: function(i) {
        return this.fromWireType(g[i]);
      }, destructorFunction: null });
    };
    function Ae() {
      Object.assign(jr.prototype, { get(r) {
        return this.allocated[r];
      }, has(r) {
        return this.allocated[r] !== void 0;
      }, allocate(r) {
        var e = this.freelist.pop() || this.allocated.length;
        return this.allocated[e] = r, e;
      }, free(r) {
        this.allocated[r] = void 0, this.freelist.push(r);
      } });
    }
    function jr() {
      this.allocated = [void 0], this.freelist = [];
    }
    var w = new jr(), xr = (r) => {
      r >= w.reserved && --w.get(r).refcount === 0 && w.free(r);
    }, Ee = () => {
      for (var r = 0, e = w.reserved; e < w.allocated.length; ++e)
        w.allocated[e] !== void 0 && ++r;
      return r;
    }, Ce = () => {
      w.allocated.push({ value: void 0 }, { value: null }, { value: !0 }, { value: !1 }), w.reserved = w.allocated.length, s.count_emval_handles = Ee;
    }, V = { toValue: (r) => (r || y("Cannot use deleted val. handle = " + r), w.get(r).value), toHandle: (r) => {
      switch (r) {
        case void 0:
          return 1;
        case null:
          return 2;
        case !0:
          return 3;
        case !1:
          return 4;
        default:
          return w.allocate({ refcount: 1, value: r });
      }
    } }, Re = (r, e) => {
      e = _(e), R(r, { name: e, fromWireType: (t) => {
        var n = V.toValue(t);
        return xr(t), n;
      }, toWireType: (t, n) => V.toHandle(n), argPackAdvance: F, readValueFromPointer: cr, destructorFunction: null });
    }, Pe = (r, e, t) => {
      if (r[e].overloadTable === void 0) {
        var n = r[e];
        r[e] = function() {
          return r[e].overloadTable.hasOwnProperty(arguments.length) || y(`Function '${t}' called with an invalid number of arguments (${arguments.length}) - expects one of (${r[e].overloadTable})!`), r[e].overloadTable[arguments.length].apply(this, arguments);
        }, r[e].overloadTable = [], r[e].overloadTable[n.argCount] = n;
      }
    }, Dr = (r, e, t) => {
      s.hasOwnProperty(r) ? ((t === void 0 || s[r].overloadTable !== void 0 && s[r].overloadTable[t] !== void 0) && y(`Cannot register public name '${r}' twice`), Pe(s, r, r), s.hasOwnProperty(t) && y(`Cannot register multiple overloads of a function with the same number of arguments (${t})!`), s[r].overloadTable[t] = e) : (s[r] = e, t !== void 0 && (s[r].numArguments = t));
    }, Fe = (r, e, t) => {
      switch (e) {
        case 1:
          return t ? function(n) {
            return this.fromWireType(S[n >> 0]);
          } : function(n) {
            return this.fromWireType(g[n >> 0]);
          };
        case 2:
          return t ? function(n) {
            return this.fromWireType(H[n >> 1]);
          } : function(n) {
            return this.fromWireType(X[n >> 1]);
          };
        case 4:
          return t ? function(n) {
            return this.fromWireType(U[n >> 2]);
          } : function(n) {
            return this.fromWireType(d[n >> 2]);
          };
        default:
          throw new TypeError(`invalid integer width (${e}): ${r}`);
      }
    }, We = (r, e, t, n) => {
      e = _(e);
      function i() {
      }
      i.values = {}, R(r, { name: e, constructor: i, fromWireType: function(a) {
        return this.constructor.values[a];
      }, toWireType: (a, o) => o.value, argPackAdvance: F, readValueFromPointer: Fe(e, t, n), destructorFunction: null }), Dr(e, i);
    }, ke = 48, Se = 57, Ue = (r) => {
      if (r === void 0)
        return "_unknown";
      r = r.replace(/[^a-zA-Z0-9_]/g, "$");
      var e = r.charCodeAt(0);
      return e >= ke && e <= Se ? `_${r}` : r;
    };
    function Ir(r, e) {
      return r = Ue(r), { [r]: function() {
        return e.apply(this, arguments);
      } }[r];
    }
    var Hr = (r) => {
      var e = Zr(r), t = _(e);
      return W(e), t;
    }, Or = (r, e) => {
      var t = D[r];
      return t === void 0 && y(e + " has unknown type " + Hr(r)), t;
    }, je = (r, e, t) => {
      var n = Or(r, "enum");
      e = _(e);
      var i = n.constructor, a = Object.create(n.constructor.prototype, { value: { value: t }, constructor: { value: Ir(`${n.name}_${e}`, function() {
      }) } });
      i.values[t] = a, i[e] = a;
    }, xe = (r, e) => {
      switch (e) {
        case 4:
          return function(t) {
            return this.fromWireType(yr[t >> 2]);
          };
        case 8:
          return function(t) {
            return this.fromWireType(mr[t >> 3]);
          };
        default:
          throw new TypeError(`invalid float width (${e}): ${r}`);
      }
    }, De = (r, e, t) => {
      e = _(e), R(r, { name: e, fromWireType: (n) => n, toWireType: (n, i) => i, argPackAdvance: F, readValueFromPointer: xe(e, t), destructorFunction: null });
    };
    function Ie(r, e, t, n, i, a) {
      var o = e.length;
      o < 2 && y("argTypes array size mismatch! Must at least get return value and 'this' types!");
      for (var f = e[1] !== null && t !== null, u = !1, c = 1; c < e.length; ++c)
        if (e[c] !== null && e[c].destructorFunction === void 0) {
          u = !0;
          break;
        }
      var v = e[0].name !== "void", l = o - 2, p = new Array(l), A = [], P = [];
      return function() {
        arguments.length !== l && y(`function ${r} called with ${arguments.length} arguments, expected ${l}`), P.length = 0;
        var I;
        A.length = f ? 2 : 1, A[0] = i, f && (I = e[1].toWireType(P, this), A[1] = I);
        for (var E = 0; E < l; ++E)
          p[E] = e[E + 2].toWireType(P, arguments[E]), A.push(p[E]);
        var G = n.apply(null, A);
        function vr(ar) {
          if (u)
            Pr(P);
          else
            for (var B = f ? 1 : 2; B < e.length; B++) {
              var It = B === 1 ? I : p[B - 2];
              e[B].destructorFunction !== null && e[B].destructorFunction(It);
            }
          if (v)
            return e[0].fromWireType(ar);
        }
        return vr(G);
      };
    }
    var He = (r, e) => {
      for (var t = [], n = 0; n < r; n++)
        t.push(d[e + n * 4 >> 2]);
      return t;
    }, Oe = (r, e, t) => {
      s.hasOwnProperty(r) || Wr("Replacing nonexistant public symbol"), s[r].overloadTable !== void 0 && t !== void 0 ? s[r].overloadTable[t] = e : (s[r] = e, s[r].argCount = t);
    }, Me = (r, e, t) => {
      var n = s["dynCall_" + r];
      return t && t.length ? n.apply(null, [e].concat(t)) : n.call(null, e);
    }, nr = [], Mr, m = (r) => {
      var e = nr[r];
      return e || (r >= nr.length && (nr.length = r + 1), nr[r] = e = Mr.get(r)), e;
    }, Ve = (r, e, t) => {
      if (r.includes("j"))
        return Me(r, e, t);
      var n = m(e).apply(null, t);
      return n;
    }, Be = (r, e) => {
      var t = [];
      return function() {
        return t.length = 0, Object.assign(t, arguments), Ve(r, e, t);
      };
    }, q = (r, e) => {
      r = _(r);
      function t() {
        return r.includes("j") ? Be(r, e) : m(e);
      }
      var n = t();
      return typeof n != "function" && y(`unknown function pointer with signature ${r}: ${e}`), n;
    }, Le = (r, e) => {
      var t = Ir(e, function(n) {
        this.name = e, this.message = n;
        var i = new Error(n).stack;
        i !== void 0 && (this.stack = this.toString() + `
` + i.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.prototype.toString = function() {
        return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;
      }, t;
    }, Vr, Ne = (r, e) => {
      var t = [], n = {};
      function i(a) {
        if (!n[a] && !D[a]) {
          if (tr[a]) {
            tr[a].forEach(i);
            return;
          }
          t.push(a), n[a] = !0;
        }
      }
      throw e.forEach(i), new Vr(`${r}: ` + t.map(Hr).join([", "]));
    }, Xe = (r) => {
      r = r.trim();
      const e = r.indexOf("(");
      return e !== -1 ? (Yr(r[r.length - 1] == ")", "Parentheses for argument names should match."), r.substr(0, e)) : r;
    }, Ze = (r, e, t, n, i, a, o) => {
      var f = He(e, t);
      r = _(r), r = Xe(r), i = q(n, i), Dr(r, function() {
        Ne(`Cannot call ${r} due to unbound types`, f);
      }, e - 1), kr([], f, function(u) {
        var c = [u[0], null].concat(u.slice(1));
        return Oe(r, Ie(r, c, null, i, a), e - 1), [];
      });
    }, qe = (r, e, t) => {
      switch (e) {
        case 1:
          return t ? (n) => S[n >> 0] : (n) => g[n >> 0];
        case 2:
          return t ? (n) => H[n >> 1] : (n) => X[n >> 1];
        case 4:
          return t ? (n) => U[n >> 2] : (n) => d[n >> 2];
        default:
          throw new TypeError(`invalid integer width (${e}): ${r}`);
      }
    }, ze = (r, e, t, n, i) => {
      e = _(e);
      var a = (v) => v;
      if (n === 0) {
        var o = 32 - 8 * t;
        a = (v) => v << o >>> o;
      }
      var f = e.includes("unsigned"), u = (v, l) => {
      }, c;
      f ? c = function(v, l) {
        return u(l, this.name), l >>> 0;
      } : c = function(v, l) {
        return u(l, this.name), l;
      }, R(r, { name: e, fromWireType: a, toWireType: c, argPackAdvance: F, readValueFromPointer: qe(e, t, n !== 0), destructorFunction: null });
    }, Ge = (r, e, t) => {
      var n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], i = n[e];
      function a(o) {
        var f = d[o >> 2], u = d[o + 4 >> 2];
        return new i(S.buffer, u, f);
      }
      t = _(t), R(r, { name: t, fromWireType: a, argPackAdvance: F, readValueFromPointer: a }, { ignoreDuplicateRegistrations: !0 });
    };
    function Ke(r) {
      return this.fromWireType(d[r >> 2]);
    }
    var Je = (r, e, t, n) => {
      if (!(n > 0))
        return 0;
      for (var i = t, a = t + n - 1, o = 0; o < r.length; ++o) {
        var f = r.charCodeAt(o);
        if (f >= 55296 && f <= 57343) {
          var u = r.charCodeAt(++o);
          f = 65536 + ((f & 1023) << 10) | u & 1023;
        }
        if (f <= 127) {
          if (t >= a)
            break;
          e[t++] = f;
        } else if (f <= 2047) {
          if (t + 1 >= a)
            break;
          e[t++] = 192 | f >> 6, e[t++] = 128 | f & 63;
        } else if (f <= 65535) {
          if (t + 2 >= a)
            break;
          e[t++] = 224 | f >> 12, e[t++] = 128 | f >> 6 & 63, e[t++] = 128 | f & 63;
        } else {
          if (t + 3 >= a)
            break;
          e[t++] = 240 | f >> 18, e[t++] = 128 | f >> 12 & 63, e[t++] = 128 | f >> 6 & 63, e[t++] = 128 | f & 63;
        }
      }
      return e[t] = 0, t - i;
    }, Qe = (r, e, t) => Je(r, g, e, t), Ye = (r) => {
      for (var e = 0, t = 0; t < r.length; ++t) {
        var n = r.charCodeAt(t);
        n <= 127 ? e++ : n <= 2047 ? e += 2 : n >= 55296 && n <= 57343 ? (e += 4, ++t) : e += 3;
      }
      return e;
    }, Br = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0, rt = (r, e, t) => {
      for (var n = e + t, i = e; r[i] && !(i >= n); )
        ++i;
      if (i - e > 16 && r.buffer && Br)
        return Br.decode(r.subarray(e, i));
      for (var a = ""; e < i; ) {
        var o = r[e++];
        if (!(o & 128)) {
          a += String.fromCharCode(o);
          continue;
        }
        var f = r[e++] & 63;
        if ((o & 224) == 192) {
          a += String.fromCharCode((o & 31) << 6 | f);
          continue;
        }
        var u = r[e++] & 63;
        if ((o & 240) == 224 ? o = (o & 15) << 12 | f << 6 | u : o = (o & 7) << 18 | f << 12 | u << 6 | r[e++] & 63, o < 65536)
          a += String.fromCharCode(o);
        else {
          var c = o - 65536;
          a += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
        }
      }
      return a;
    }, et = (r, e) => r ? rt(g, r, e) : "", tt = (r, e) => {
      e = _(e);
      var t = e === "std::string";
      R(r, { name: e, fromWireType(n) {
        var i = d[n >> 2], a = n + 4, o;
        if (t)
          for (var f = a, u = 0; u <= i; ++u) {
            var c = a + u;
            if (u == i || g[c] == 0) {
              var v = c - f, l = et(f, v);
              o === void 0 ? o = l : (o += "\0", o += l), f = c + 1;
            }
          }
        else {
          for (var p = new Array(i), u = 0; u < i; ++u)
            p[u] = String.fromCharCode(g[a + u]);
          o = p.join("");
        }
        return W(n), o;
      }, toWireType(n, i) {
        i instanceof ArrayBuffer && (i = new Uint8Array(i));
        var a, o = typeof i == "string";
        o || i instanceof Uint8Array || i instanceof Uint8ClampedArray || i instanceof Int8Array || y("Cannot pass non-string to std::string"), t && o ? a = Ye(i) : a = i.length;
        var f = lr(4 + a + 1), u = f + 4;
        if (d[f >> 2] = a, t && o)
          Qe(i, u, a + 1);
        else if (o)
          for (var c = 0; c < a; ++c) {
            var v = i.charCodeAt(c);
            v > 255 && (W(u), y("String has UTF-16 code units that do not fit in 8 bits")), g[u + c] = v;
          }
        else
          for (var c = 0; c < a; ++c)
            g[u + c] = i[c];
        return n !== null && n.push(W, f), f;
      }, argPackAdvance: F, readValueFromPointer: Ke, destructorFunction(n) {
        W(n);
      } });
    }, Lr = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0, nt = (r, e) => {
      for (var t = r, n = t >> 1, i = n + e / 2; !(n >= i) && X[n]; )
        ++n;
      if (t = n << 1, t - r > 32 && Lr)
        return Lr.decode(g.subarray(r, t));
      for (var a = "", o = 0; !(o >= e / 2); ++o) {
        var f = H[r + o * 2 >> 1];
        if (f == 0)
          break;
        a += String.fromCharCode(f);
      }
      return a;
    }, it = (r, e, t) => {
      if (t === void 0 && (t = 2147483647), t < 2)
        return 0;
      t -= 2;
      for (var n = e, i = t < r.length * 2 ? t / 2 : r.length, a = 0; a < i; ++a) {
        var o = r.charCodeAt(a);
        H[e >> 1] = o, e += 2;
      }
      return H[e >> 1] = 0, e - n;
    }, at = (r) => r.length * 2, ot = (r, e) => {
      for (var t = 0, n = ""; !(t >= e / 4); ) {
        var i = U[r + t * 4 >> 2];
        if (i == 0)
          break;
        if (++t, i >= 65536) {
          var a = i - 65536;
          n += String.fromCharCode(55296 | a >> 10, 56320 | a & 1023);
        } else
          n += String.fromCharCode(i);
      }
      return n;
    }, st = (r, e, t) => {
      if (t === void 0 && (t = 2147483647), t < 4)
        return 0;
      for (var n = e, i = n + t - 4, a = 0; a < r.length; ++a) {
        var o = r.charCodeAt(a);
        if (o >= 55296 && o <= 57343) {
          var f = r.charCodeAt(++a);
          o = 65536 + ((o & 1023) << 10) | f & 1023;
        }
        if (U[e >> 2] = o, e += 4, e + 4 > i)
          break;
      }
      return U[e >> 2] = 0, e - n;
    }, ft = (r) => {
      for (var e = 0, t = 0; t < r.length; ++t) {
        var n = r.charCodeAt(t);
        n >= 55296 && n <= 57343 && ++t, e += 4;
      }
      return e;
    }, ut = (r, e, t) => {
      t = _(t);
      var n, i, a, o, f;
      e === 2 ? (n = nt, i = it, o = at, a = () => X, f = 1) : e === 4 && (n = ot, i = st, o = ft, a = () => d, f = 2), R(r, { name: t, fromWireType: (u) => {
        for (var c = d[u >> 2], v = a(), l, p = u + 4, A = 0; A <= c; ++A) {
          var P = u + 4 + A * e;
          if (A == c || v[P >> f] == 0) {
            var I = P - p, E = n(p, I);
            l === void 0 ? l = E : (l += "\0", l += E), p = P + e;
          }
        }
        return W(u), l;
      }, toWireType: (u, c) => {
        typeof c != "string" && y(`Cannot pass non-string to C++ string type ${t}`);
        var v = o(c), l = lr(4 + v + e);
        return d[l >> 2] = v >> f, i(c, l + 4, v + e), u !== null && u.push(W, l), l;
      }, argPackAdvance: F, readValueFromPointer: cr, destructorFunction(u) {
        W(u);
      } });
    }, ct = (r, e, t, n, i, a) => {
      er[r] = { name: _(e), rawConstructor: q(t, n), rawDestructor: q(i, a), fields: [] };
    }, lt = (r, e, t, n, i, a, o, f, u, c) => {
      er[r].fields.push({ fieldName: _(e), getterReturnType: t, getter: q(n, i), getterContext: a, setterArgumentType: o, setter: q(f, u), setterContext: c });
    }, vt = (r, e) => {
      e = _(e), R(r, { isVoid: !0, name: e, argPackAdvance: 0, fromWireType: () => {
      }, toWireType: (t, n) => {
      } });
    }, dt = {}, ht = (r) => {
      var e = dt[r];
      return e === void 0 ? _(r) : e;
    }, Nr = () => {
      if (typeof globalThis == "object")
        return globalThis;
      function r(e) {
        e.$$$embind_global$$$ = e;
        var t = typeof $$$embind_global$$$ == "object" && e.$$$embind_global$$$ == e;
        return t || delete e.$$$embind_global$$$, t;
      }
      if (typeof $$$embind_global$$$ == "object" || (typeof global == "object" && r(global) ? $$$embind_global$$$ = global : typeof self == "object" && r(self) && ($$$embind_global$$$ = self), typeof $$$embind_global$$$ == "object"))
        return $$$embind_global$$$;
      throw Error("unable to get global object.");
    }, _t = (r) => r === 0 ? V.toHandle(Nr()) : (r = ht(r), V.toHandle(Nr()[r])), pt = (r) => {
      r > 4 && (w.get(r).refcount += 1);
    }, gt = (r) => {
      var e = new Array(r + 1);
      return function(t, n, i) {
        e[0] = t;
        for (var a = 0; a < r; ++a) {
          var o = Or(d[n + a * 4 >> 2], "parameter " + a);
          e[a + 1] = o.readValueFromPointer(i), i += o.argPackAdvance;
        }
        var f = new (t.bind.apply(t, e))();
        return V.toHandle(f);
      };
    }, Xr = {}, yt = (r, e, t, n) => {
      r = V.toValue(r);
      var i = Xr[e];
      return i || (i = gt(e), Xr[e] = i), i(r, t, n);
    }, mt = () => {
      rr("");
    }, bt = (r, e, t) => g.copyWithin(r, e, e + t), wt = () => 2147483648, Tt = (r) => {
      var e = Y.buffer, t = (r - e.byteLength + 65535) / 65536;
      try {
        return Y.grow(t), br(), 1;
      } catch {
      }
    }, $t = (r) => {
      var e = g.length;
      r >>>= 0;
      var t = wt();
      if (r > t)
        return !1;
      for (var n = (u, c) => u + (c - u % c) % c, i = 1; i <= 4; i *= 2) {
        var a = e * (1 + 0.2 / i);
        a = Math.min(a, r + 100663296);
        var o = Math.min(t, n(Math.max(r, a), 65536)), f = Tt(o);
        if (f)
          return !0;
      }
      return !1;
    }, At = (r) => r;
    Fr = s.InternalError = class extends Error {
      constructor(e) {
        super(e), this.name = "InternalError";
      }
    }, we(), Ur = s.BindingError = class extends Error {
      constructor(e) {
        super(e), this.name = "BindingError";
      }
    }, Ae(), Ce(), Vr = s.UnboundTypeError = Le(Error, "UnboundTypeError");
    var Et = { r: ve, q: de, g: _e, d: pe, k: ge, a: ye, i: he, M: me, C: be, I: $e, G: Re, K: We, b: je, w: De, L: Ze, h: ze, e: Ge, v: tt, p: ut, x: ct, N: lt, J: vt, y: xr, B: _t, s: pt, A: yt, t: mt, F: bt, E: $t, c: Ct, l: kt, o: xt, z: Wt, n: St, f: Rt, u: Dt, m: jt, D: Ft, H: Pt, j: Ut, O: At }, h = le(), lr = s._malloc = (r) => (lr = s._malloc = h.R)(r), W = s._free = (r) => (W = s._free = h.S)(r), Zr = (r) => (Zr = h.U)(r);
    s.__embind_initialize_bindings = () => (s.__embind_initialize_bindings = h.V)();
    var b = (r, e) => (b = h.W)(r, e), z = (r) => (z = h.X)(r), T = () => (T = h.Y)(), $ = (r) => ($ = h.Z)(r), qr = (r) => (qr = h._)(r), zr = (r) => (zr = h.$)(r), Gr = (r, e, t) => (Gr = h.aa)(r, e, t), Kr = (r) => (Kr = h.ba)(r);
    function Ct(r, e) {
      var t = T();
      try {
        return m(r)(e);
      } catch (n) {
        if ($(t), n !== n + 0)
          throw n;
        b(1, 0);
      }
    }
    function Rt(r, e) {
      var t = T();
      try {
        m(r)(e);
      } catch (n) {
        if ($(t), n !== n + 0)
          throw n;
        b(1, 0);
      }
    }
    function Pt(r, e, t, n, i, a) {
      var o = T();
      try {
        m(r)(e, t, n, i, a);
      } catch (f) {
        if ($(o), f !== f + 0)
          throw f;
        b(1, 0);
      }
    }
    function Ft(r, e, t, n, i) {
      var a = T();
      try {
        m(r)(e, t, n, i);
      } catch (o) {
        if ($(a), o !== o + 0)
          throw o;
        b(1, 0);
      }
    }
    function Wt(r, e, t, n, i) {
      var a = T();
      try {
        return m(r)(e, t, n, i);
      } catch (o) {
        if ($(a), o !== o + 0)
          throw o;
        b(1, 0);
      }
    }
    function kt(r, e, t) {
      var n = T();
      try {
        return m(r)(e, t);
      } catch (i) {
        if ($(n), i !== i + 0)
          throw i;
        b(1, 0);
      }
    }
    function St(r) {
      var e = T();
      try {
        m(r)();
      } catch (t) {
        if ($(e), t !== t + 0)
          throw t;
        b(1, 0);
      }
    }
    function Ut(r, e, t, n, i, a, o, f, u, c, v) {
      var l = T();
      try {
        m(r)(e, t, n, i, a, o, f, u, c, v);
      } catch (p) {
        if ($(l), p !== p + 0)
          throw p;
        b(1, 0);
      }
    }
    function jt(r, e, t, n) {
      var i = T();
      try {
        m(r)(e, t, n);
      } catch (a) {
        if ($(i), a !== a + 0)
          throw a;
        b(1, 0);
      }
    }
    function xt(r, e, t, n) {
      var i = T();
      try {
        return m(r)(e, t, n);
      } catch (a) {
        if ($(i), a !== a + 0)
          throw a;
        b(1, 0);
      }
    }
    function Dt(r, e, t) {
      var n = T();
      try {
        m(r)(e, t);
      } catch (i) {
        if ($(n), i !== i + 0)
          throw i;
        b(1, 0);
      }
    }
    var ir;
    Z = function r() {
      ir || Jr(), ir || (Z = r);
    };
    function Jr() {
      if (j > 0 || (re(), j > 0))
        return;
      function r() {
        ir || (ir = !0, s.calledRun = !0, !gr && (ee(), hr(s), s.onRuntimeInitialized && s.onRuntimeInitialized(), te()));
      }
      s.setStatus ? (s.setStatus("Running..."), setTimeout(function() {
        setTimeout(function() {
          s.setStatus("");
        }, 1), r();
      }, 1)) : r();
    }
    if (s.preInit)
      for (typeof s.preInit == "function" && (s.preInit = [s.preInit]); s.preInit.length > 0; )
        s.preInit.pop()();
    return Jr(), K.ready;
  };
})();
function Nt(k) {
  return Ht(
    dr,
    k
  );
}
function Xt(k) {
  return Ot(
    dr,
    k
  );
}
async function Zt(k, K) {
  return Mt(
    dr,
    k,
    K
  );
}
export {
  Gt as barcodeFormats,
  Kt as characterSets,
  Jt as defaultEncodeHints,
  Nt as getZXingModule,
  Qt as purgeZXingModule,
  Xt as setZXingModuleOverrides,
  Zt as writeBarcodeToImageFile,
  Yt as writeInputEccLevels
};
