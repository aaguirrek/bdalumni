import { defineComponent as It, ref as Fe, onMounted as oo, onUnmounted as io, computed as Mt, watch as Rt, toRefs as so, openBlock as Ut, createElementBlock as jt, createElementVNode as tt, normalizeStyle as co, withDirectives as uo, vShow as lo, renderSlot as Or, withModifiers as rt } from "vue";
var Dr = (r, a, o) => {
  if (!a.has(r))
    throw TypeError("Cannot " + o);
}, br = (r, a, o) => (Dr(r, a, "read from private field"), o ? o.call(r) : a.get(r)), fo = (r, a, o) => {
  if (a.has(r))
    throw TypeError("Cannot add the same private member more than once");
  a instanceof WeakSet ? a.add(r) : a.set(r, o);
}, ho = (r, a, o, c) => (Dr(r, a, "write to private field"), c ? c.call(r, o) : a.set(r, o), o);
const Ar = [
  ["aztec", "Aztec"],
  ["code_128", "Code128"],
  ["code_39", "Code39"],
  ["code_93", "Code93"],
  ["codabar", "Codabar"],
  ["databar", "DataBar"],
  ["databar_expanded", "DataBarExpanded"],
  ["data_matrix", "DataMatrix"],
  ["dx_film_edge", "DXFilmEdge"],
  ["ean_13", "EAN-13"],
  ["ean_8", "EAN-8"],
  ["itf", "ITF"],
  ["maxi_code", "MaxiCode"],
  ["micro_qr_code", "MicroQRCode"],
  ["pdf417", "PDF417"],
  ["qr_code", "QRCode"],
  ["rm_qr_code", "rMQRCode"],
  ["upc_a", "UPC-A"],
  ["upc_e", "UPC-E"],
  ["linear_codes", "Linear-Codes"],
  ["matrix_codes", "Matrix-Codes"]
], po = [...Ar, ["unknown"]].map((r) => r[0]), nt = new Map(
  Ar
);
function mo(r) {
  for (const [a, o] of nt)
    if (r === o)
      return a;
  return "unknown";
}
function vo(r) {
  if (Mr(r))
    return {
      width: r.naturalWidth,
      height: r.naturalHeight
    };
  if (Rr(r))
    return {
      width: r.width.baseVal.value,
      height: r.height.baseVal.value
    };
  if (xr(r))
    return {
      width: r.videoWidth,
      height: r.videoHeight
    };
  if (Fr(r))
    return {
      width: r.width,
      height: r.height
    };
  if (Ur(r))
    return {
      width: r.displayWidth,
      height: r.displayHeight
    };
  if (kr(r))
    return {
      width: r.width,
      height: r.height
    };
  if (Ir(r))
    return {
      width: r.width,
      height: r.height
    };
  throw new TypeError(
    "The provided value is not of type '(Blob or HTMLCanvasElement or HTMLImageElement or HTMLVideoElement or ImageBitmap or ImageData or OffscreenCanvas or SVGImageElement or VideoFrame)'."
  );
}
function Mr(r) {
  try {
    return r instanceof HTMLImageElement;
  } catch (a) {
    return !1;
  }
}
function Rr(r) {
  try {
    return r instanceof SVGImageElement;
  } catch (a) {
    return !1;
  }
}
function xr(r) {
  try {
    return r instanceof HTMLVideoElement;
  } catch (a) {
    return !1;
  }
}
function kr(r) {
  try {
    return r instanceof HTMLCanvasElement;
  } catch (a) {
    return !1;
  }
}
function Fr(r) {
  try {
    return r instanceof ImageBitmap;
  } catch (a) {
    return !1;
  }
}
function Ir(r) {
  try {
    return r instanceof OffscreenCanvas;
  } catch (a) {
    return !1;
  }
}
function Ur(r) {
  try {
    return r instanceof VideoFrame;
  } catch (a) {
    return !1;
  }
}
function jr(r) {
  try {
    return r instanceof Blob;
  } catch (a) {
    return !1;
  }
}
function yo(r) {
  try {
    return r instanceof ImageData;
  } catch (a) {
    return !1;
  }
}
function go(r, a) {
  try {
    const o = new OffscreenCanvas(r, a);
    if (o.getContext("2d") instanceof OffscreenCanvasRenderingContext2D)
      return o;
    throw void 0;
  } catch (o) {
    const c = document.createElement("canvas");
    return c.width = r, c.height = a, c;
  }
}
async function Wr(r) {
  if (Mr(r) && !await _o(r))
    throw new DOMException(
      "Failed to load or decode HTMLImageElement.",
      "InvalidStateError"
    );
  if (Rr(r) && !await $o(r))
    throw new DOMException(
      "Failed to load or decode SVGImageElement.",
      "InvalidStateError"
    );
  if (Ur(r) && So(r))
    throw new DOMException("VideoFrame is closed.", "InvalidStateError");
  if (xr(r) && (r.readyState === 0 || r.readyState === 1))
    throw new DOMException("Invalid element or state.", "InvalidStateError");
  if (Fr(r) && To(r))
    throw new DOMException(
      "The image source is detached.",
      "InvalidStateError"
    );
  const { width: a, height: o } = vo(r);
  if (a === 0 || o === 0)
    return null;
  const c = go(a, o).getContext("2d");
  c.drawImage(r, 0, 0);
  try {
    return c.getImageData(0, 0, a, o);
  } catch (l) {
    throw new DOMException("Source would taint origin.", "SecurityError");
  }
}
async function wo(r) {
  let a;
  try {
    if (globalThis.createImageBitmap)
      a = await createImageBitmap(r);
    else if (globalThis.Image) {
      a = new Image();
      let o = "";
      try {
        o = URL.createObjectURL(r), a.src = o, await a.decode();
      } finally {
        URL.revokeObjectURL(o);
      }
    } else
      return r;
  } catch (o) {
    throw new DOMException(
      "Failed to load or decode Blob.",
      "InvalidStateError"
    );
  }
  return await Wr(a);
}
function bo(r) {
  const { width: a, height: o } = r;
  if (a === 0 || o === 0)
    return null;
  const c = r.getContext("2d");
  try {
    return c.getImageData(0, 0, a, o);
  } catch (l) {
    throw new DOMException("Source would taint origin.", "SecurityError");
  }
}
async function Co(r) {
  if (jr(r))
    return await wo(r);
  if (yo(r)) {
    if (Po(r))
      throw new DOMException(
        "The image data has been detached.",
        "InvalidStateError"
      );
    return r;
  }
  return kr(r) || Ir(r) ? bo(r) : await Wr(r);
}
async function _o(r) {
  try {
    return await r.decode(), !0;
  } catch (a) {
    return !1;
  }
}
async function $o(r) {
  var a;
  try {
    return await ((a = r.decode) == null ? void 0 : a.call(r)), !0;
  } catch (o) {
    return !1;
  }
}
function So(r) {
  return r.format === null;
}
function Po(r) {
  return r.data.buffer.byteLength === 0;
}
function To(r) {
  return r.width === 0 && r.height === 0;
}
function Cr(r, a) {
  return r instanceof DOMException ? new DOMException(`${a}: ${r.message}`, r.name) : r instanceof Error ? new r.constructor(`${a}: ${r.message}`) : new Error(`${a}: ${r}`);
}
const _r = [
  "Aztec",
  "Codabar",
  "Code128",
  "Code39",
  "Code93",
  "DataBar",
  "DataBarExpanded",
  "DataMatrix",
  "DXFilmEdge",
  "EAN-13",
  "EAN-8",
  "ITF",
  "Linear-Codes",
  "Matrix-Codes",
  "MaxiCode",
  "MicroQRCode",
  "None",
  "PDF417",
  "QRCode",
  "rMQRCode",
  "UPC-A",
  "UPC-E"
];
function Eo(r) {
  return r.join("|");
}
function Oo(r) {
  const a = $r(r);
  let o = 0, c = _r.length - 1;
  for (; o <= c; ) {
    const l = Math.floor((o + c) / 2), h = _r[l], v = $r(h);
    if (v === a)
      return h;
    v < a ? o = l + 1 : c = l - 1;
  }
  return "None";
}
function $r(r) {
  return r.toLowerCase().replace(/_-\[\]/g, "");
}
function Do(r, a) {
  return r.Binarizer[a];
}
function Ao(r, a) {
  return r.CharacterSet[a];
}
const Mo = [
  "Text",
  "Binary",
  "Mixed",
  "GS1",
  "ISO15434",
  "UnknownECI"
];
function Ro(r) {
  return Mo[r.value];
}
function xo(r, a) {
  return r.EanAddOnSymbol[a];
}
function ko(r, a) {
  return r.TextMode[a];
}
const Ue = {
  formats: [],
  tryHarder: !0,
  tryRotate: !0,
  tryInvert: !0,
  tryDownscale: !0,
  binarizer: "LocalAverage",
  isPure: !1,
  downscaleFactor: 3,
  downscaleThreshold: 500,
  minLineCount: 2,
  maxNumberOfSymbols: 255,
  tryCode39ExtendedMode: !1,
  validateCode39CheckSum: !1,
  validateITFCheckSum: !1,
  returnCodabarStartEnd: !1,
  returnErrors: !1,
  eanAddOnSymbol: "Read",
  textMode: "Plain",
  characterSet: "Unknown"
};
function Lr(r, a) {
  return {
    ...a,
    formats: Eo(a.formats),
    binarizer: Do(r, a.binarizer),
    eanAddOnSymbol: xo(
      r,
      a.eanAddOnSymbol
    ),
    textMode: ko(r, a.textMode),
    characterSet: Ao(
      r,
      a.characterSet
    )
  };
}
const Fo = {
  width: 200,
  height: 200,
  format: "QRCode",
  characterSet: "UTF8",
  eccLevel: -1,
  margin: 10
};
function Hr(r) {
  return {
    ...r,
    format: Oo(r.format),
    eccLevel: r.eccLevel,
    contentType: Ro(r.contentType)
  };
}
const Io = {
  locateFile: (r, a) => {
    const o = r.match(/_(.+?)\.wasm$/);
    return o ? `https://fastly.jsdelivr.net/npm/zxing-wasm@1.1.1/dist/${o[1]}/${r}` : a + r;
  }
};
let kt = /* @__PURE__ */ new WeakMap();
function Wt(r, a) {
  var o;
  const c = kt.get(r);
  if (c != null && c.modulePromise && (a === void 0 || Object.is(a, c.moduleOverrides)))
    return c.modulePromise;
  const l = (o = a != null ? a : c == null ? void 0 : c.moduleOverrides) != null ? o : Io, h = r({
    ...l
  });
  return kt.set(r, {
    moduleOverrides: l,
    modulePromise: h
  }), h;
}
function Uo(r, a) {
  kt.set(r, {
    moduleOverrides: a
  });
}
async function jo(r, a, o = Ue) {
  const c = {
    ...Ue,
    ...o
  }, l = await Wt(r), { size: h } = a, v = new Uint8Array(await a.arrayBuffer()), g = l._malloc(h);
  l.HEAPU8.set(v, g);
  const b = l.readBarcodesFromImage(
    g,
    h,
    Lr(l, c)
  );
  l._free(g);
  const p = [];
  for (let _ = 0; _ < b.size(); ++_)
    p.push(
      Hr(b.get(_))
    );
  return p;
}
async function Wo(r, a, o = Ue) {
  const c = {
    ...Ue,
    ...o
  }, l = await Wt(r), {
    data: h,
    width: v,
    height: g,
    data: { byteLength: b }
  } = a, p = l._malloc(b);
  l.HEAPU8.set(h, p);
  const _ = l.readBarcodesFromPixmap(
    p,
    v,
    g,
    Lr(l, c)
  );
  l._free(p);
  const S = [];
  for (let C = 0; C < _.size(); ++C)
    S.push(
      Hr(_.get(C))
    );
  return S;
}
structuredClone(Ue);
structuredClone(Fo);
var it = (() => {
  var r = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
  return function(a = {}) {
    var o = a, c, l;
    o.ready = new Promise((e, t) => {
      c = e, l = t;
    });
    var h = Object.assign({}, o), v = "./this.program", g = typeof window == "object", b = typeof importScripts == "function";
    typeof process == "object" && typeof process.versions == "object" && process.versions.node;
    var p = "";
    function _(e) {
      return o.locateFile ? o.locateFile(e, p) : p + e;
    }
    var S;
    (g || b) && (b ? p = self.location.href : typeof document < "u" && document.currentScript && (p = document.currentScript.src), r && (p = r), p.indexOf("blob:") !== 0 ? p = p.substr(0, p.replace(/[?#].*/, "").lastIndexOf("/") + 1) : p = "", b && (S = (e) => {
      var t = new XMLHttpRequest();
      return t.open("GET", e, !1), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response);
    })), o.print || console.log.bind(console);
    var C = o.printErr || console.error.bind(console);
    Object.assign(o, h), h = null, o.arguments && o.arguments, o.thisProgram && (v = o.thisProgram), o.quit && o.quit;
    var F;
    o.wasmBinary && (F = o.wasmBinary), typeof WebAssembly != "object" && me("no native wasm support detected");
    var k, I = !1;
    function L(e, t) {
      e || me(t);
    }
    var R, O, x, N, W, M, we, be;
    function Pe() {
      var e = k.buffer;
      o.HEAP8 = R = new Int8Array(e), o.HEAP16 = x = new Int16Array(e), o.HEAPU8 = O = new Uint8Array(e), o.HEAPU16 = N = new Uint16Array(e), o.HEAP32 = W = new Int32Array(e), o.HEAPU32 = M = new Uint32Array(e), o.HEAPF32 = we = new Float32Array(e), o.HEAPF64 = be = new Float64Array(e);
    }
    var Te = [], Ee = [], je = [];
    function ct() {
      if (o.preRun)
        for (typeof o.preRun == "function" && (o.preRun = [o.preRun]); o.preRun.length; )
          Oe(o.preRun.shift());
      pt(Te);
    }
    function ut() {
      pt(Ee);
    }
    function lt() {
      if (o.postRun)
        for (typeof o.postRun == "function" && (o.postRun = [o.postRun]); o.postRun.length; )
          dt(o.postRun.shift());
      pt(je);
    }
    function Oe(e) {
      Te.unshift(e);
    }
    function We(e) {
      Ee.unshift(e);
    }
    function dt(e) {
      je.unshift(e);
    }
    var ie = 0, K = null;
    function re(e) {
      ie++, o.monitorRunDependencies && o.monitorRunDependencies(ie);
    }
    function ft(e) {
      if (ie--, o.monitorRunDependencies && o.monitorRunDependencies(ie), ie == 0 && K) {
        var t = K;
        K = null, t();
      }
    }
    function me(e) {
      o.onAbort && o.onAbort(e), e = "Aborted(" + e + ")", C(e), I = !0, e += ". Build with -sASSERTIONS for more info.";
      var t = new WebAssembly.RuntimeError(e);
      throw l(t), t;
    }
    var ht = "data:application/octet-stream;base64,", Le = (e) => e.startsWith(ht), le;
    le = "zxing_reader.wasm", Le(le) || (le = _(le));
    function He(e) {
      if (e == le && F)
        return new Uint8Array(F);
      if (S)
        return S(e);
      throw "both async and sync fetching of the wasm failed";
    }
    function tn(e) {
      return !F && (g || b) && typeof fetch == "function" ? fetch(e, { credentials: "same-origin" }).then((t) => {
        if (!t.ok)
          throw "failed to load wasm binary file at '" + e + "'";
        return t.arrayBuffer();
      }).catch(() => He(e)) : Promise.resolve().then(() => He(e));
    }
    function Ht(e, t, n) {
      return tn(e).then((i) => WebAssembly.instantiate(i, t)).then((i) => i).then(n, (i) => {
        C(`failed to asynchronously prepare wasm: ${i}`), me(i);
      });
    }
    function rn(e, t, n, i) {
      return !e && typeof WebAssembly.instantiateStreaming == "function" && !Le(t) && typeof fetch == "function" ? fetch(t, { credentials: "same-origin" }).then((s) => {
        var u = WebAssembly.instantiateStreaming(s, n);
        return u.then(i, function(d) {
          return C(`wasm streaming compile failed: ${d}`), C("falling back to ArrayBuffer instantiation"), Ht(t, n, i);
        });
      }) : Ht(t, n, i);
    }
    function nn() {
      var e = { a: ja };
      function t(i, s) {
        return H = i.exports, k = H.fa, Pe(), Kt = H.ja, We(H.ga), ft(), H;
      }
      re();
      function n(i) {
        t(i.instance);
      }
      if (o.instantiateWasm)
        try {
          return o.instantiateWasm(e, t);
        } catch (i) {
          C(`Module.instantiateWasm callback failed with error: ${i}`), l(i);
        }
      return rn(F, le, e, n).catch(l), {};
    }
    var pt = (e) => {
      for (; e.length > 0; )
        e.shift()(o);
    };
    o.noExitRuntime;
    var Be = [], Ve = 0, an = (e) => {
      var t = new mt(e);
      return t.get_caught() || (t.set_caught(!0), Ve--), t.set_rethrown(!1), Be.push(t), mr(t.excPtr), t.get_exception_ptr();
    }, se = 0, on = () => {
      B(0, 0);
      var e = Be.pop();
      pr(e.excPtr), se = 0;
    };
    function mt(e) {
      this.excPtr = e, this.ptr = e - 24, this.set_type = function(t) {
        M[this.ptr + 4 >> 2] = t;
      }, this.get_type = function() {
        return M[this.ptr + 4 >> 2];
      }, this.set_destructor = function(t) {
        M[this.ptr + 8 >> 2] = t;
      }, this.get_destructor = function() {
        return M[this.ptr + 8 >> 2];
      }, this.set_caught = function(t) {
        t = t ? 1 : 0, R[this.ptr + 12 >> 0] = t;
      }, this.get_caught = function() {
        return R[this.ptr + 12 >> 0] != 0;
      }, this.set_rethrown = function(t) {
        t = t ? 1 : 0, R[this.ptr + 13 >> 0] = t;
      }, this.get_rethrown = function() {
        return R[this.ptr + 13 >> 0] != 0;
      }, this.init = function(t, n) {
        this.set_adjusted_ptr(0), this.set_type(t), this.set_destructor(n);
      }, this.set_adjusted_ptr = function(t) {
        M[this.ptr + 16 >> 2] = t;
      }, this.get_adjusted_ptr = function() {
        return M[this.ptr + 16 >> 2];
      }, this.get_exception_ptr = function() {
        var t = yr(this.get_type());
        if (t)
          return M[this.excPtr >> 2];
        var n = this.get_adjusted_ptr();
        return n !== 0 ? n : this.excPtr;
      };
    }
    var sn = (e) => {
      throw se || (se = e), se;
    }, vt = (e) => {
      var t = se;
      if (!t)
        return ke(0), 0;
      var n = new mt(t);
      n.set_adjusted_ptr(t);
      var i = n.get_type();
      if (!i)
        return ke(0), t;
      for (var s in e) {
        var u = e[s];
        if (u === 0 || u === i)
          break;
        var d = n.ptr + 16;
        if (vr(u, i, d))
          return ke(u), t;
      }
      return ke(i), t;
    }, cn = () => vt([]), un = (e) => vt([e]), ln = (e, t) => vt([e, t]), dn = () => {
      var e = Be.pop();
      e || me("no exception to throw");
      var t = e.excPtr;
      throw e.get_rethrown() || (Be.push(e), e.set_rethrown(!0), e.set_caught(!1), Ve++), se = t, se;
    }, fn = (e, t, n) => {
      var i = new mt(e);
      throw i.init(t, n), se = e, Ve++, se;
    }, hn = () => Ve, ze = {}, Bt = (e) => {
      for (; e.length; ) {
        var t = e.pop(), n = e.pop();
        n(t);
      }
    };
    function yt(e) {
      return this.fromWireType(W[e >> 2]);
    }
    var Ce = {}, ve = {}, Ge = {}, Vt, qe = (e) => {
      throw new Vt(e);
    }, ye = (e, t, n) => {
      e.forEach(function(f) {
        Ge[f] = t;
      });
      function i(f) {
        var m = n(f);
        m.length !== e.length && qe("Mismatched type converter count");
        for (var w = 0; w < e.length; ++w)
          ne(e[w], m[w]);
      }
      var s = new Array(t.length), u = [], d = 0;
      t.forEach((f, m) => {
        ve.hasOwnProperty(f) ? s[m] = ve[f] : (u.push(f), Ce.hasOwnProperty(f) || (Ce[f] = []), Ce[f].push(() => {
          s[m] = ve[f], ++d, d === u.length && i(s);
        }));
      }), u.length === 0 && i(s);
    }, pn = (e) => {
      var t = ze[e];
      delete ze[e];
      var n = t.rawConstructor, i = t.rawDestructor, s = t.fields, u = s.map((d) => d.getterReturnType).concat(s.map((d) => d.setterArgumentType));
      ye([e], u, (d) => {
        var f = {};
        return s.forEach((m, w) => {
          var $ = m.fieldName, T = d[w], E = m.getter, D = m.getterContext, U = d[w + s.length], Q = m.setter, j = m.setterContext;
          f[$] = { read: (X) => T.fromWireType(E(D, X)), write: (X, y) => {
            var P = [];
            Q(j, X, U.toWireType(P, y)), Bt(P);
          } };
        }), [{ name: t.name, fromWireType: (m) => {
          var w = {};
          for (var $ in f)
            w[$] = f[$].read(m);
          return i(m), w;
        }, toWireType: (m, w) => {
          for (var $ in f)
            if (!($ in w))
              throw new TypeError(`Missing field: "${$}"`);
          var T = n();
          for ($ in f)
            f[$].write(T, w[$]);
          return m !== null && m.push(i, T), T;
        }, argPackAdvance: ae, readValueFromPointer: yt, destructorFunction: i }];
      });
    }, mn = (e, t, n, i, s) => {
    }, vn = () => {
      for (var e = new Array(256), t = 0; t < 256; ++t)
        e[t] = String.fromCharCode(t);
      zt = e;
    }, zt, J = (e) => {
      for (var t = "", n = e; O[n]; )
        t += zt[O[n++]];
      return t;
    }, _e, A = (e) => {
      throw new _e(e);
    };
    function yn(e, t, n = {}) {
      var i = t.name;
      if (e || A(`type "${i}" must have a positive integer typeid pointer`), ve.hasOwnProperty(e)) {
        if (n.ignoreDuplicateRegistrations)
          return;
        A(`Cannot register type '${i}' twice`);
      }
      if (ve[e] = t, delete Ge[e], Ce.hasOwnProperty(e)) {
        var s = Ce[e];
        delete Ce[e], s.forEach((u) => u());
      }
    }
    function ne(e, t, n = {}) {
      if (!("argPackAdvance" in t))
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      return yn(e, t, n);
    }
    var ae = 8, gn = (e, t, n, i) => {
      t = J(t), ne(e, { name: t, fromWireType: function(s) {
        return !!s;
      }, toWireType: function(s, u) {
        return u ? n : i;
      }, argPackAdvance: ae, readValueFromPointer: function(s) {
        return this.fromWireType(O[s]);
      }, destructorFunction: null });
    }, wn = (e) => ({ count: e.count, deleteScheduled: e.deleteScheduled, preservePointerOnDelete: e.preservePointerOnDelete, ptr: e.ptr, ptrType: e.ptrType, smartPtr: e.smartPtr, smartPtrType: e.smartPtrType }), gt = (e) => {
      function t(n) {
        return n.$$.ptrType.registeredClass.name;
      }
      A(t(e) + " instance already deleted");
    }, wt = !1, Gt = (e) => {
    }, bn = (e) => {
      e.smartPtr ? e.smartPtrType.rawDestructor(e.smartPtr) : e.ptrType.registeredClass.rawDestructor(e.ptr);
    }, qt = (e) => {
      e.count.value -= 1;
      var t = e.count.value === 0;
      t && bn(e);
    }, Nt = (e, t, n) => {
      if (t === n)
        return e;
      if (n.baseClass === void 0)
        return null;
      var i = Nt(e, t, n.baseClass);
      return i === null ? null : n.downcast(i);
    }, Yt = {}, Cn = () => Object.keys(Me).length, _n = () => {
      var e = [];
      for (var t in Me)
        Me.hasOwnProperty(t) && e.push(Me[t]);
      return e;
    }, De = [], bt = () => {
      for (; De.length; ) {
        var e = De.pop();
        e.$$.deleteScheduled = !1, e.delete();
      }
    }, Ae, $n = (e) => {
      Ae = e, De.length && Ae && Ae(bt);
    }, Sn = () => {
      o.getInheritedInstanceCount = Cn, o.getLiveInheritedInstances = _n, o.flushPendingDeletes = bt, o.setDelayFunction = $n;
    }, Me = {}, Pn = (e, t) => {
      for (t === void 0 && A("ptr should not be undefined"); e.baseClass; )
        t = e.upcast(t), e = e.baseClass;
      return t;
    }, Tn = (e, t) => (t = Pn(e, t), Me[t]), Ne = (e, t) => {
      (!t.ptrType || !t.ptr) && qe("makeClassHandle requires ptr and ptrType");
      var n = !!t.smartPtrType, i = !!t.smartPtr;
      return n !== i && qe("Both smartPtrType and smartPtr must be specified"), t.count = { value: 1 }, Re(Object.create(e, { $$: { value: t } }));
    };
    function En(e) {
      var t = this.getPointee(e);
      if (!t)
        return this.destructor(e), null;
      var n = Tn(this.registeredClass, t);
      if (n !== void 0) {
        if (n.$$.count.value === 0)
          return n.$$.ptr = t, n.$$.smartPtr = e, n.clone();
        var i = n.clone();
        return this.destructor(e), i;
      }
      function s() {
        return this.isSmartPointer ? Ne(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: t, smartPtrType: this, smartPtr: e }) : Ne(this.registeredClass.instancePrototype, { ptrType: this, ptr: e });
      }
      var u = this.registeredClass.getActualType(t), d = Yt[u];
      if (!d)
        return s.call(this);
      var f;
      this.isConst ? f = d.constPointerType : f = d.pointerType;
      var m = Nt(t, this.registeredClass, f.registeredClass);
      return m === null ? s.call(this) : this.isSmartPointer ? Ne(f.registeredClass.instancePrototype, { ptrType: f, ptr: m, smartPtrType: this, smartPtr: e }) : Ne(f.registeredClass.instancePrototype, { ptrType: f, ptr: m });
    }
    var Re = (e) => typeof FinalizationRegistry > "u" ? (Re = (t) => t, e) : (wt = new FinalizationRegistry((t) => {
      qt(t.$$);
    }), Re = (t) => {
      var n = t.$$, i = !!n.smartPtr;
      if (i) {
        var s = { $$: n };
        wt.register(t, s, t);
      }
      return t;
    }, Gt = (t) => wt.unregister(t), Re(e)), On = () => {
      Object.assign(Ye.prototype, { isAliasOf(e) {
        if (!(this instanceof Ye) || !(e instanceof Ye))
          return !1;
        var t = this.$$.ptrType.registeredClass, n = this.$$.ptr;
        e.$$ = e.$$;
        for (var i = e.$$.ptrType.registeredClass, s = e.$$.ptr; t.baseClass; )
          n = t.upcast(n), t = t.baseClass;
        for (; i.baseClass; )
          s = i.upcast(s), i = i.baseClass;
        return t === i && n === s;
      }, clone() {
        if (this.$$.ptr || gt(this), this.$$.preservePointerOnDelete)
          return this.$$.count.value += 1, this;
        var e = Re(Object.create(Object.getPrototypeOf(this), { $$: { value: wn(this.$$) } }));
        return e.$$.count.value += 1, e.$$.deleteScheduled = !1, e;
      }, delete() {
        this.$$.ptr || gt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && A("Object already scheduled for deletion"), Gt(this), qt(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
      }, isDeleted() {
        return !this.$$.ptr;
      }, deleteLater() {
        return this.$$.ptr || gt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && A("Object already scheduled for deletion"), De.push(this), De.length === 1 && Ae && Ae(bt), this.$$.deleteScheduled = !0, this;
      } });
    };
    function Ye() {
    }
    var Dn = 48, An = 57, Jt = (e) => {
      if (e === void 0)
        return "_unknown";
      e = e.replace(/[^a-zA-Z0-9_]/g, "$");
      var t = e.charCodeAt(0);
      return t >= Dn && t <= An ? `_${e}` : e;
    };
    function Ct(e, t) {
      return e = Jt(e), { [e]: function() {
        return t.apply(this, arguments);
      } }[e];
    }
    var Qt = (e, t, n) => {
      if (e[t].overloadTable === void 0) {
        var i = e[t];
        e[t] = function() {
          return e[t].overloadTable.hasOwnProperty(arguments.length) || A(`Function '${n}' called with an invalid number of arguments (${arguments.length}) - expects one of (${e[t].overloadTable})!`), e[t].overloadTable[arguments.length].apply(this, arguments);
        }, e[t].overloadTable = [], e[t].overloadTable[i.argCount] = i;
      }
    }, _t = (e, t, n) => {
      o.hasOwnProperty(e) ? ((n === void 0 || o[e].overloadTable !== void 0 && o[e].overloadTable[n] !== void 0) && A(`Cannot register public name '${e}' twice`), Qt(o, e, e), o.hasOwnProperty(n) && A(`Cannot register multiple overloads of a function with the same number of arguments (${n})!`), o[e].overloadTable[n] = t) : (o[e] = t, n !== void 0 && (o[e].numArguments = n));
    };
    function Mn(e, t, n, i, s, u, d, f) {
      this.name = e, this.constructor = t, this.instancePrototype = n, this.rawDestructor = i, this.baseClass = s, this.getActualType = u, this.upcast = d, this.downcast = f, this.pureVirtualFunctions = [];
    }
    var $t = (e, t, n) => {
      for (; t !== n; )
        t.upcast || A(`Expected null or instance of ${n.name}, got an instance of ${t.name}`), e = t.upcast(e), t = t.baseClass;
      return e;
    };
    function Rn(e, t) {
      if (t === null)
        return this.isReference && A(`null is not a valid ${this.name}`), 0;
      t.$$ || A(`Cannot pass "${Et(t)}" as a ${this.name}`), t.$$.ptr || A(`Cannot pass deleted object as a pointer of type ${this.name}`);
      var n = t.$$.ptrType.registeredClass, i = $t(t.$$.ptr, n, this.registeredClass);
      return i;
    }
    function xn(e, t) {
      var n;
      if (t === null)
        return this.isReference && A(`null is not a valid ${this.name}`), this.isSmartPointer ? (n = this.rawConstructor(), e !== null && e.push(this.rawDestructor, n), n) : 0;
      t.$$ || A(`Cannot pass "${Et(t)}" as a ${this.name}`), t.$$.ptr || A(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && t.$$.ptrType.isConst && A(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);
      var i = t.$$.ptrType.registeredClass;
      if (n = $t(t.$$.ptr, i, this.registeredClass), this.isSmartPointer)
        switch (t.$$.smartPtr === void 0 && A("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) {
          case 0:
            t.$$.smartPtrType === this ? n = t.$$.smartPtr : A(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);
            break;
          case 1:
            n = t.$$.smartPtr;
            break;
          case 2:
            if (t.$$.smartPtrType === this)
              n = t.$$.smartPtr;
            else {
              var s = t.clone();
              n = this.rawShare(n, de.toHandle(() => s.delete())), e !== null && e.push(this.rawDestructor, n);
            }
            break;
          default:
            A("Unsupporting sharing policy");
        }
      return n;
    }
    function kn(e, t) {
      if (t === null)
        return this.isReference && A(`null is not a valid ${this.name}`), 0;
      t.$$ || A(`Cannot pass "${Et(t)}" as a ${this.name}`), t.$$.ptr || A(`Cannot pass deleted object as a pointer of type ${this.name}`), t.$$.ptrType.isConst && A(`Cannot convert argument of type ${t.$$.ptrType.name} to parameter type ${this.name}`);
      var n = t.$$.ptrType.registeredClass, i = $t(t.$$.ptr, n, this.registeredClass);
      return i;
    }
    function Xt(e) {
      return this.fromWireType(M[e >> 2]);
    }
    var Fn = () => {
      Object.assign(Je.prototype, { getPointee(e) {
        return this.rawGetPointee && (e = this.rawGetPointee(e)), e;
      }, destructor(e) {
        this.rawDestructor && this.rawDestructor(e);
      }, argPackAdvance: ae, readValueFromPointer: Xt, deleteObject(e) {
        e !== null && e.delete();
      }, fromWireType: En });
    };
    function Je(e, t, n, i, s, u, d, f, m, w, $) {
      this.name = e, this.registeredClass = t, this.isReference = n, this.isConst = i, this.isSmartPointer = s, this.pointeeType = u, this.sharingPolicy = d, this.rawGetPointee = f, this.rawConstructor = m, this.rawShare = w, this.rawDestructor = $, !s && t.baseClass === void 0 ? i ? (this.toWireType = Rn, this.destructorFunction = null) : (this.toWireType = kn, this.destructorFunction = null) : this.toWireType = xn;
    }
    var Zt = (e, t, n) => {
      o.hasOwnProperty(e) || qe("Replacing nonexistant public symbol"), o[e].overloadTable !== void 0 && n !== void 0 ? o[e].overloadTable[n] = t : (o[e] = t, o[e].argCount = n);
    }, In = (e, t, n) => {
      var i = o["dynCall_" + e];
      return n && n.length ? i.apply(null, [t].concat(n)) : i.call(null, t);
    }, Qe = [], Kt, V = (e) => {
      var t = Qe[e];
      return t || (e >= Qe.length && (Qe.length = e + 1), Qe[e] = t = Kt.get(e)), t;
    }, Un = (e, t, n) => {
      if (e.includes("j"))
        return In(e, t, n);
      var i = V(t).apply(null, n);
      return i;
    }, jn = (e, t) => {
      var n = [];
      return function() {
        return n.length = 0, Object.assign(n, arguments), Un(e, t, n);
      };
    }, te = (e, t) => {
      e = J(e);
      function n() {
        return e.includes("j") ? jn(e, t) : V(t);
      }
      var i = n();
      return typeof i != "function" && A(`unknown function pointer with signature ${e}: ${t}`), i;
    }, Wn = (e, t) => {
      var n = Ct(t, function(i) {
        this.name = t, this.message = i;
        var s = new Error(i).stack;
        s !== void 0 && (this.stack = this.toString() + `
` + s.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.prototype.toString = function() {
        return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;
      }, n;
    }, er, tr = (e) => {
      var t = hr(e), n = J(t);
      return ce(t), n;
    }, Xe = (e, t) => {
      var n = [], i = {};
      function s(u) {
        if (!i[u] && !ve[u]) {
          if (Ge[u]) {
            Ge[u].forEach(s);
            return;
          }
          n.push(u), i[u] = !0;
        }
      }
      throw t.forEach(s), new er(`${e}: ` + n.map(tr).join([", "]));
    }, Ln = (e, t, n, i, s, u, d, f, m, w, $, T, E) => {
      $ = J($), u = te(s, u), f && (f = te(d, f)), w && (w = te(m, w)), E = te(T, E);
      var D = Jt($);
      _t(D, function() {
        Xe(`Cannot construct ${$} due to unbound types`, [i]);
      }), ye([e, t, n], i ? [i] : [], function(U) {
        U = U[0];
        var Q, j;
        i ? (Q = U.registeredClass, j = Q.instancePrototype) : j = Ye.prototype;
        var X = Ct(D, function() {
          if (Object.getPrototypeOf(this) !== y)
            throw new _e("Use 'new' to construct " + $);
          if (P.constructor_body === void 0)
            throw new _e($ + " has no accessible constructor");
          var et = P.constructor_body[arguments.length];
          if (et === void 0)
            throw new _e(`Tried to invoke ctor of ${$} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(P.constructor_body).toString()}) parameters instead!`);
          return et.apply(this, arguments);
        }), y = Object.create(j, { constructor: { value: X } });
        X.prototype = y;
        var P = new Mn($, X, y, E, Q, u, f, w);
        P.baseClass && (P.baseClass.__derivedClasses === void 0 && (P.baseClass.__derivedClasses = []), P.baseClass.__derivedClasses.push(P));
        var q = new Je($, P, !0, !1, !1), Y = new Je($ + "*", P, !1, !1, !1), ge = new Je($ + " const*", P, !1, !0, !1);
        return Yt[e] = { pointerType: Y, constPointerType: ge }, Zt(D, X), [q, Y, ge];
      });
    }, St = (e, t) => {
      for (var n = [], i = 0; i < e; i++)
        n.push(M[t + i * 4 >> 2]);
      return n;
    };
    function Pt(e, t, n, i, s, u) {
      var d = t.length;
      d < 2 && A("argTypes array size mismatch! Must at least get return value and 'this' types!");
      for (var f = t[1] !== null && n !== null, m = !1, w = 1; w < t.length; ++w)
        if (t[w] !== null && t[w].destructorFunction === void 0) {
          m = !0;
          break;
        }
      var $ = t[0].name !== "void", T = d - 2, E = new Array(T), D = [], U = [];
      return function() {
        arguments.length !== T && A(`function ${e} called with ${arguments.length} arguments, expected ${T}`), U.length = 0;
        var Q;
        D.length = f ? 2 : 1, D[0] = s, f && (Q = t[1].toWireType(U, this), D[1] = Q);
        for (var j = 0; j < T; ++j)
          E[j] = t[j + 2].toWireType(U, arguments[j]), D.push(E[j]);
        var X = i.apply(null, D);
        function y(P) {
          if (m)
            Bt(U);
          else
            for (var q = f ? 1 : 2; q < t.length; q++) {
              var Y = q === 1 ? Q : E[q - 2];
              t[q].destructorFunction !== null && t[q].destructorFunction(Y);
            }
          if ($)
            return t[0].fromWireType(P);
        }
        return y(X);
      };
    }
    var Hn = (e, t, n, i, s, u) => {
      var d = St(t, n);
      s = te(i, s), ye([], [e], function(f) {
        f = f[0];
        var m = `constructor ${f.name}`;
        if (f.registeredClass.constructor_body === void 0 && (f.registeredClass.constructor_body = []), f.registeredClass.constructor_body[t - 1] !== void 0)
          throw new _e(`Cannot register multiple constructors with identical number of parameters (${t - 1}) for class '${f.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
        return f.registeredClass.constructor_body[t - 1] = () => {
          Xe(`Cannot construct ${f.name} due to unbound types`, d);
        }, ye([], d, (w) => (w.splice(1, 0, null), f.registeredClass.constructor_body[t - 1] = Pt(m, w, null, s, u), [])), [];
      });
    }, rr = (e) => {
      e = e.trim();
      const t = e.indexOf("(");
      return t !== -1 ? (L(e[e.length - 1] == ")", "Parentheses for argument names should match."), e.substr(0, t)) : e;
    }, Bn = (e, t, n, i, s, u, d, f, m) => {
      var w = St(n, i);
      t = J(t), t = rr(t), u = te(s, u), ye([], [e], function($) {
        $ = $[0];
        var T = `${$.name}.${t}`;
        t.startsWith("@@") && (t = Symbol[t.substring(2)]), f && $.registeredClass.pureVirtualFunctions.push(t);
        function E() {
          Xe(`Cannot call ${T} due to unbound types`, w);
        }
        var D = $.registeredClass.instancePrototype, U = D[t];
        return U === void 0 || U.overloadTable === void 0 && U.className !== $.name && U.argCount === n - 2 ? (E.argCount = n - 2, E.className = $.name, D[t] = E) : (Qt(D, t, T), D[t].overloadTable[n - 2] = E), ye([], w, function(Q) {
          var j = Pt(T, Q, $, u, d);
          return D[t].overloadTable === void 0 ? (j.argCount = n - 2, D[t] = j) : D[t].overloadTable[n - 2] = j, [];
        }), [];
      });
    };
    function Vn() {
      Object.assign(nr.prototype, { get(e) {
        return this.allocated[e];
      }, has(e) {
        return this.allocated[e] !== void 0;
      }, allocate(e) {
        var t = this.freelist.pop() || this.allocated.length;
        return this.allocated[t] = e, t;
      }, free(e) {
        this.allocated[e] = void 0, this.freelist.push(e);
      } });
    }
    function nr() {
      this.allocated = [void 0], this.freelist = [];
    }
    var ee = new nr(), ar = (e) => {
      e >= ee.reserved && --ee.get(e).refcount === 0 && ee.free(e);
    }, zn = () => {
      for (var e = 0, t = ee.reserved; t < ee.allocated.length; ++t)
        ee.allocated[t] !== void 0 && ++e;
      return e;
    }, Gn = () => {
      ee.allocated.push({ value: void 0 }, { value: null }, { value: !0 }, { value: !1 }), ee.reserved = ee.allocated.length, o.count_emval_handles = zn;
    }, de = { toValue: (e) => (e || A("Cannot use deleted val. handle = " + e), ee.get(e).value), toHandle: (e) => {
      switch (e) {
        case void 0:
          return 1;
        case null:
          return 2;
        case !0:
          return 3;
        case !1:
          return 4;
        default:
          return ee.allocate({ refcount: 1, value: e });
      }
    } }, qn = (e, t) => {
      t = J(t), ne(e, { name: t, fromWireType: (n) => {
        var i = de.toValue(n);
        return ar(n), i;
      }, toWireType: (n, i) => de.toHandle(i), argPackAdvance: ae, readValueFromPointer: yt, destructorFunction: null });
    }, Nn = (e, t, n) => {
      switch (t) {
        case 1:
          return n ? function(i) {
            return this.fromWireType(R[i >> 0]);
          } : function(i) {
            return this.fromWireType(O[i >> 0]);
          };
        case 2:
          return n ? function(i) {
            return this.fromWireType(x[i >> 1]);
          } : function(i) {
            return this.fromWireType(N[i >> 1]);
          };
        case 4:
          return n ? function(i) {
            return this.fromWireType(W[i >> 2]);
          } : function(i) {
            return this.fromWireType(M[i >> 2]);
          };
        default:
          throw new TypeError(`invalid integer width (${t}): ${e}`);
      }
    }, Yn = (e, t, n, i) => {
      t = J(t);
      function s() {
      }
      s.values = {}, ne(e, { name: t, constructor: s, fromWireType: function(u) {
        return this.constructor.values[u];
      }, toWireType: (u, d) => d.value, argPackAdvance: ae, readValueFromPointer: Nn(t, n, i), destructorFunction: null }), _t(t, s);
    }, Tt = (e, t) => {
      var n = ve[e];
      return n === void 0 && A(t + " has unknown type " + tr(e)), n;
    }, Jn = (e, t, n) => {
      var i = Tt(e, "enum");
      t = J(t);
      var s = i.constructor, u = Object.create(i.constructor.prototype, { value: { value: n }, constructor: { value: Ct(`${i.name}_${t}`, function() {
      }) } });
      s.values[n] = u, s[t] = u;
    }, Et = (e) => {
      if (e === null)
        return "null";
      var t = typeof e;
      return t === "object" || t === "array" || t === "function" ? e.toString() : "" + e;
    }, Qn = (e, t) => {
      switch (t) {
        case 4:
          return function(n) {
            return this.fromWireType(we[n >> 2]);
          };
        case 8:
          return function(n) {
            return this.fromWireType(be[n >> 3]);
          };
        default:
          throw new TypeError(`invalid float width (${t}): ${e}`);
      }
    }, Xn = (e, t, n) => {
      t = J(t), ne(e, { name: t, fromWireType: (i) => i, toWireType: (i, s) => s, argPackAdvance: ae, readValueFromPointer: Qn(t, n), destructorFunction: null });
    }, Zn = (e, t, n, i, s, u, d) => {
      var f = St(t, n);
      e = J(e), e = rr(e), s = te(i, s), _t(e, function() {
        Xe(`Cannot call ${e} due to unbound types`, f);
      }, t - 1), ye([], f, function(m) {
        var w = [m[0], null].concat(m.slice(1));
        return Zt(e, Pt(e, w, null, s, u), t - 1), [];
      });
    }, Kn = (e, t, n) => {
      switch (t) {
        case 1:
          return n ? (i) => R[i >> 0] : (i) => O[i >> 0];
        case 2:
          return n ? (i) => x[i >> 1] : (i) => N[i >> 1];
        case 4:
          return n ? (i) => W[i >> 2] : (i) => M[i >> 2];
        default:
          throw new TypeError(`invalid integer width (${t}): ${e}`);
      }
    }, ea = (e, t, n, i, s) => {
      t = J(t);
      var u = ($) => $;
      if (i === 0) {
        var d = 32 - 8 * n;
        u = ($) => $ << d >>> d;
      }
      var f = t.includes("unsigned"), m = ($, T) => {
      }, w;
      f ? w = function($, T) {
        return m(T, this.name), T >>> 0;
      } : w = function($, T) {
        return m(T, this.name), T;
      }, ne(e, { name: t, fromWireType: u, toWireType: w, argPackAdvance: ae, readValueFromPointer: Kn(t, n, i !== 0), destructorFunction: null });
    }, ta = (e, t, n) => {
      var i = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], s = i[t];
      function u(d) {
        var f = M[d >> 2], m = M[d + 4 >> 2];
        return new s(R.buffer, m, f);
      }
      n = J(n), ne(e, { name: n, fromWireType: u, argPackAdvance: ae, readValueFromPointer: u }, { ignoreDuplicateRegistrations: !0 });
    }, or = (e, t, n, i) => {
      if (!(i > 0))
        return 0;
      for (var s = n, u = n + i - 1, d = 0; d < e.length; ++d) {
        var f = e.charCodeAt(d);
        if (f >= 55296 && f <= 57343) {
          var m = e.charCodeAt(++d);
          f = 65536 + ((f & 1023) << 10) | m & 1023;
        }
        if (f <= 127) {
          if (n >= u)
            break;
          t[n++] = f;
        } else if (f <= 2047) {
          if (n + 1 >= u)
            break;
          t[n++] = 192 | f >> 6, t[n++] = 128 | f & 63;
        } else if (f <= 65535) {
          if (n + 2 >= u)
            break;
          t[n++] = 224 | f >> 12, t[n++] = 128 | f >> 6 & 63, t[n++] = 128 | f & 63;
        } else {
          if (n + 3 >= u)
            break;
          t[n++] = 240 | f >> 18, t[n++] = 128 | f >> 12 & 63, t[n++] = 128 | f >> 6 & 63, t[n++] = 128 | f & 63;
        }
      }
      return t[n] = 0, n - s;
    }, ra = (e, t, n) => or(e, O, t, n), ir = (e) => {
      for (var t = 0, n = 0; n < e.length; ++n) {
        var i = e.charCodeAt(n);
        i <= 127 ? t++ : i <= 2047 ? t += 2 : i >= 55296 && i <= 57343 ? (t += 4, ++n) : t += 3;
      }
      return t;
    }, sr = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0, na = (e, t, n) => {
      for (var i = t + n, s = t; e[s] && !(s >= i); )
        ++s;
      if (s - t > 16 && e.buffer && sr)
        return sr.decode(e.subarray(t, s));
      for (var u = ""; t < s; ) {
        var d = e[t++];
        if (!(d & 128)) {
          u += String.fromCharCode(d);
          continue;
        }
        var f = e[t++] & 63;
        if ((d & 224) == 192) {
          u += String.fromCharCode((d & 31) << 6 | f);
          continue;
        }
        var m = e[t++] & 63;
        if ((d & 240) == 224 ? d = (d & 15) << 12 | f << 6 | m : d = (d & 7) << 18 | f << 12 | m << 6 | e[t++] & 63, d < 65536)
          u += String.fromCharCode(d);
        else {
          var w = d - 65536;
          u += String.fromCharCode(55296 | w >> 10, 56320 | w & 1023);
        }
      }
      return u;
    }, Ot = (e, t) => e ? na(O, e, t) : "", aa = (e, t) => {
      t = J(t);
      var n = t === "std::string";
      ne(e, { name: t, fromWireType(i) {
        var s = M[i >> 2], u = i + 4, d;
        if (n)
          for (var f = u, m = 0; m <= s; ++m) {
            var w = u + m;
            if (m == s || O[w] == 0) {
              var $ = w - f, T = Ot(f, $);
              d === void 0 ? d = T : (d += "\0", d += T), f = w + 1;
            }
          }
        else {
          for (var E = new Array(s), m = 0; m < s; ++m)
            E[m] = String.fromCharCode(O[u + m]);
          d = E.join("");
        }
        return ce(i), d;
      }, toWireType(i, s) {
        s instanceof ArrayBuffer && (s = new Uint8Array(s));
        var u, d = typeof s == "string";
        d || s instanceof Uint8Array || s instanceof Uint8ClampedArray || s instanceof Int8Array || A("Cannot pass non-string to std::string"), n && d ? u = ir(s) : u = s.length;
        var f = At(4 + u + 1), m = f + 4;
        if (M[f >> 2] = u, n && d)
          ra(s, m, u + 1);
        else if (d)
          for (var w = 0; w < u; ++w) {
            var $ = s.charCodeAt(w);
            $ > 255 && (ce(m), A("String has UTF-16 code units that do not fit in 8 bits")), O[m + w] = $;
          }
        else
          for (var w = 0; w < u; ++w)
            O[m + w] = s[w];
        return i !== null && i.push(ce, f), f;
      }, argPackAdvance: ae, readValueFromPointer: Xt, destructorFunction(i) {
        ce(i);
      } });
    }, cr = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0, oa = (e, t) => {
      for (var n = e, i = n >> 1, s = i + t / 2; !(i >= s) && N[i]; )
        ++i;
      if (n = i << 1, n - e > 32 && cr)
        return cr.decode(O.subarray(e, n));
      for (var u = "", d = 0; !(d >= t / 2); ++d) {
        var f = x[e + d * 2 >> 1];
        if (f == 0)
          break;
        u += String.fromCharCode(f);
      }
      return u;
    }, ia = (e, t, n) => {
      if (n === void 0 && (n = 2147483647), n < 2)
        return 0;
      n -= 2;
      for (var i = t, s = n < e.length * 2 ? n / 2 : e.length, u = 0; u < s; ++u) {
        var d = e.charCodeAt(u);
        x[t >> 1] = d, t += 2;
      }
      return x[t >> 1] = 0, t - i;
    }, sa = (e) => e.length * 2, ca = (e, t) => {
      for (var n = 0, i = ""; !(n >= t / 4); ) {
        var s = W[e + n * 4 >> 2];
        if (s == 0)
          break;
        if (++n, s >= 65536) {
          var u = s - 65536;
          i += String.fromCharCode(55296 | u >> 10, 56320 | u & 1023);
        } else
          i += String.fromCharCode(s);
      }
      return i;
    }, ua = (e, t, n) => {
      if (n === void 0 && (n = 2147483647), n < 4)
        return 0;
      for (var i = t, s = i + n - 4, u = 0; u < e.length; ++u) {
        var d = e.charCodeAt(u);
        if (d >= 55296 && d <= 57343) {
          var f = e.charCodeAt(++u);
          d = 65536 + ((d & 1023) << 10) | f & 1023;
        }
        if (W[t >> 2] = d, t += 4, t + 4 > s)
          break;
      }
      return W[t >> 2] = 0, t - i;
    }, la = (e) => {
      for (var t = 0, n = 0; n < e.length; ++n) {
        var i = e.charCodeAt(n);
        i >= 55296 && i <= 57343 && ++n, t += 4;
      }
      return t;
    }, da = (e, t, n) => {
      n = J(n);
      var i, s, u, d, f;
      t === 2 ? (i = oa, s = ia, d = sa, u = () => N, f = 1) : t === 4 && (i = ca, s = ua, d = la, u = () => M, f = 2), ne(e, { name: n, fromWireType: (m) => {
        for (var w = M[m >> 2], $ = u(), T, E = m + 4, D = 0; D <= w; ++D) {
          var U = m + 4 + D * t;
          if (D == w || $[U >> f] == 0) {
            var Q = U - E, j = i(E, Q);
            T === void 0 ? T = j : (T += "\0", T += j), E = U + t;
          }
        }
        return ce(m), T;
      }, toWireType: (m, w) => {
        typeof w != "string" && A(`Cannot pass non-string to C++ string type ${n}`);
        var $ = d(w), T = At(4 + $ + t);
        return M[T >> 2] = $ >> f, s(w, T + 4, $ + t), m !== null && m.push(ce, T), T;
      }, argPackAdvance: ae, readValueFromPointer: yt, destructorFunction(m) {
        ce(m);
      } });
    }, fa = (e, t, n, i, s, u) => {
      ze[e] = { name: J(t), rawConstructor: te(n, i), rawDestructor: te(s, u), fields: [] };
    }, ha = (e, t, n, i, s, u, d, f, m, w) => {
      ze[e].fields.push({ fieldName: J(t), getterReturnType: n, getter: te(i, s), getterContext: u, setterArgumentType: d, setter: te(f, m), setterContext: w });
    }, pa = (e, t) => {
      t = J(t), ne(e, { isVoid: !0, name: t, argPackAdvance: 0, fromWireType: () => {
      }, toWireType: (n, i) => {
      } });
    }, ma = {}, va = (e) => {
      var t = ma[e];
      return t === void 0 ? J(e) : t;
    }, ur = () => {
      if (typeof globalThis == "object")
        return globalThis;
      function e(t) {
        t.$$$embind_global$$$ = t;
        var n = typeof $$$embind_global$$$ == "object" && t.$$$embind_global$$$ == t;
        return n || delete t.$$$embind_global$$$, n;
      }
      if (typeof $$$embind_global$$$ == "object" || (typeof global == "object" && e(global) ? $$$embind_global$$$ = global : typeof self == "object" && e(self) && ($$$embind_global$$$ = self), typeof $$$embind_global$$$ == "object"))
        return $$$embind_global$$$;
      throw Error("unable to get global object.");
    }, ya = (e) => e === 0 ? de.toHandle(ur()) : (e = va(e), de.toHandle(ur()[e])), ga = (e) => {
      e > 4 && (ee.get(e).refcount += 1);
    }, wa = (e) => {
      var t = new Array(e + 1);
      return function(n, i, s) {
        t[0] = n;
        for (var u = 0; u < e; ++u) {
          var d = Tt(M[i + u * 4 >> 2], "parameter " + u);
          t[u + 1] = d.readValueFromPointer(s), s += d.argPackAdvance;
        }
        var f = new (n.bind.apply(n, t))();
        return de.toHandle(f);
      };
    }, lr = {}, ba = (e, t, n, i) => {
      e = de.toValue(e);
      var s = lr[t];
      return s || (s = wa(t), lr[t] = s), s(e, n, i);
    }, Ca = (e, t) => {
      e = Tt(e, "_emval_take_value");
      var n = e.readValueFromPointer(t);
      return de.toHandle(n);
    }, _a = () => {
      me("");
    }, $a = (e, t, n) => O.copyWithin(e, t, t + n), Sa = () => 2147483648, Pa = (e) => {
      var t = k.buffer, n = (e - t.byteLength + 65535) / 65536;
      try {
        return k.grow(n), Pe(), 1;
      } catch (i) {
      }
    }, Ta = (e) => {
      var t = O.length;
      e >>>= 0;
      var n = Sa();
      if (e > n)
        return !1;
      for (var i = (m, w) => m + (w - m % w) % w, s = 1; s <= 4; s *= 2) {
        var u = t * (1 + 0.2 / s);
        u = Math.min(u, e + 100663296);
        var d = Math.min(n, i(Math.max(e, u), 65536)), f = Pa(d);
        if (f)
          return !0;
      }
      return !1;
    }, Dt = {}, Ea = () => v || "./this.program", xe = () => {
      if (!xe.strings) {
        var e = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", t = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: e, _: Ea() };
        for (var n in Dt)
          Dt[n] === void 0 ? delete t[n] : t[n] = Dt[n];
        var i = [];
        for (var n in t)
          i.push(`${n}=${t[n]}`);
        xe.strings = i;
      }
      return xe.strings;
    }, Oa = (e, t) => {
      for (var n = 0; n < e.length; ++n)
        R[t++ >> 0] = e.charCodeAt(n);
      R[t >> 0] = 0;
    }, Da = (e, t) => {
      var n = 0;
      return xe().forEach((i, s) => {
        var u = t + n;
        M[e + s * 4 >> 2] = u, Oa(i, u), n += i.length + 1;
      }), 0;
    }, Aa = (e, t) => {
      var n = xe();
      M[e >> 2] = n.length;
      var i = 0;
      return n.forEach((s) => i += s.length + 1), M[t >> 2] = i, 0;
    }, Ma = (e) => e, Ze = (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0), Ra = (e, t) => {
      for (var n = 0, i = 0; i <= t; n += e[i++])
        ;
      return n;
    }, dr = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], fr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], xa = (e, t) => {
      for (var n = new Date(e.getTime()); t > 0; ) {
        var i = Ze(n.getFullYear()), s = n.getMonth(), u = (i ? dr : fr)[s];
        if (t > u - n.getDate())
          t -= u - n.getDate() + 1, n.setDate(1), s < 11 ? n.setMonth(s + 1) : (n.setMonth(0), n.setFullYear(n.getFullYear() + 1));
        else
          return n.setDate(n.getDate() + t), n;
      }
      return n;
    };
    function ka(e, t, n) {
      var i = n > 0 ? n : ir(e) + 1, s = new Array(i), u = or(e, s, 0, s.length);
      return t && (s.length = u), s;
    }
    var Fa = (e, t) => {
      R.set(e, t);
    }, Ia = (e, t, n, i) => {
      var s = M[i + 40 >> 2], u = { tm_sec: W[i >> 2], tm_min: W[i + 4 >> 2], tm_hour: W[i + 8 >> 2], tm_mday: W[i + 12 >> 2], tm_mon: W[i + 16 >> 2], tm_year: W[i + 20 >> 2], tm_wday: W[i + 24 >> 2], tm_yday: W[i + 28 >> 2], tm_isdst: W[i + 32 >> 2], tm_gmtoff: W[i + 36 >> 2], tm_zone: s ? Ot(s) : "" }, d = Ot(n), f = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
      for (var m in f)
        d = d.replace(new RegExp(m, "g"), f[m]);
      var w = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], $ = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      function T(y, P, q) {
        for (var Y = typeof y == "number" ? y.toString() : y || ""; Y.length < P; )
          Y = q[0] + Y;
        return Y;
      }
      function E(y, P) {
        return T(y, P, "0");
      }
      function D(y, P) {
        function q(ge) {
          return ge < 0 ? -1 : ge > 0 ? 1 : 0;
        }
        var Y;
        return (Y = q(y.getFullYear() - P.getFullYear())) === 0 && (Y = q(y.getMonth() - P.getMonth())) === 0 && (Y = q(y.getDate() - P.getDate())), Y;
      }
      function U(y) {
        switch (y.getDay()) {
          case 0:
            return new Date(y.getFullYear() - 1, 11, 29);
          case 1:
            return y;
          case 2:
            return new Date(y.getFullYear(), 0, 3);
          case 3:
            return new Date(y.getFullYear(), 0, 2);
          case 4:
            return new Date(y.getFullYear(), 0, 1);
          case 5:
            return new Date(y.getFullYear() - 1, 11, 31);
          case 6:
            return new Date(y.getFullYear() - 1, 11, 30);
        }
      }
      function Q(y) {
        var P = xa(new Date(y.tm_year + 1900, 0, 1), y.tm_yday), q = new Date(P.getFullYear(), 0, 4), Y = new Date(P.getFullYear() + 1, 0, 4), ge = U(q), et = U(Y);
        return D(ge, P) <= 0 ? D(et, P) <= 0 ? P.getFullYear() + 1 : P.getFullYear() : P.getFullYear() - 1;
      }
      var j = { "%a": (y) => w[y.tm_wday].substring(0, 3), "%A": (y) => w[y.tm_wday], "%b": (y) => $[y.tm_mon].substring(0, 3), "%B": (y) => $[y.tm_mon], "%C": (y) => {
        var P = y.tm_year + 1900;
        return E(P / 100 | 0, 2);
      }, "%d": (y) => E(y.tm_mday, 2), "%e": (y) => T(y.tm_mday, 2, " "), "%g": (y) => Q(y).toString().substring(2), "%G": (y) => Q(y), "%H": (y) => E(y.tm_hour, 2), "%I": (y) => {
        var P = y.tm_hour;
        return P == 0 ? P = 12 : P > 12 && (P -= 12), E(P, 2);
      }, "%j": (y) => E(y.tm_mday + Ra(Ze(y.tm_year + 1900) ? dr : fr, y.tm_mon - 1), 3), "%m": (y) => E(y.tm_mon + 1, 2), "%M": (y) => E(y.tm_min, 2), "%n": () => `
`, "%p": (y) => y.tm_hour >= 0 && y.tm_hour < 12 ? "AM" : "PM", "%S": (y) => E(y.tm_sec, 2), "%t": () => "	", "%u": (y) => y.tm_wday || 7, "%U": (y) => {
        var P = y.tm_yday + 7 - y.tm_wday;
        return E(Math.floor(P / 7), 2);
      }, "%V": (y) => {
        var P = Math.floor((y.tm_yday + 7 - (y.tm_wday + 6) % 7) / 7);
        if ((y.tm_wday + 371 - y.tm_yday - 2) % 7 <= 2 && P++, P) {
          if (P == 53) {
            var q = (y.tm_wday + 371 - y.tm_yday) % 7;
            q != 4 && (q != 3 || !Ze(y.tm_year)) && (P = 1);
          }
        } else {
          P = 52;
          var Y = (y.tm_wday + 7 - y.tm_yday - 1) % 7;
          (Y == 4 || Y == 5 && Ze(y.tm_year % 400 - 1)) && P++;
        }
        return E(P, 2);
      }, "%w": (y) => y.tm_wday, "%W": (y) => {
        var P = y.tm_yday + 7 - (y.tm_wday + 6) % 7;
        return E(Math.floor(P / 7), 2);
      }, "%y": (y) => (y.tm_year + 1900).toString().substring(2), "%Y": (y) => y.tm_year + 1900, "%z": (y) => {
        var P = y.tm_gmtoff, q = P >= 0;
        return P = Math.abs(P) / 60, P = P / 60 * 100 + P % 60, (q ? "+" : "-") + ("0000" + P).slice(-4);
      }, "%Z": (y) => y.tm_zone, "%%": () => "%" };
      d = d.replace(/%%/g, "\0\0");
      for (var m in j)
        d.includes(m) && (d = d.replace(new RegExp(m, "g"), j[m](u)));
      d = d.replace(/\0\0/g, "%");
      var X = ka(d, !1);
      return X.length > t ? 0 : (Fa(X, e), X.length - 1);
    }, Ua = (e, t, n, i, s) => Ia(e, t, n, i);
    Vt = o.InternalError = class extends Error {
      constructor(e) {
        super(e), this.name = "InternalError";
      }
    }, vn(), _e = o.BindingError = class extends Error {
      constructor(e) {
        super(e), this.name = "BindingError";
      }
    }, On(), Sn(), Fn(), er = o.UnboundTypeError = Wn(Error, "UnboundTypeError"), Vn(), Gn();
    var ja = { s: an, v: on, b: cn, g: un, q: ln, I: dn, f: fn, T: hn, d: sn, ba: pn, P: mn, Y: gn, aa: Ln, $: Hn, w: Bn, X: qn, x: Yn, h: Jn, K: Xn, L: Zn, t: ea, n: ta, J: aa, C: da, A: fa, ca: ha, Z: pa, ea: ar, da: ya, M: ga, V: ba, _: Ca, B: _a, W: $a, U: Ta, R: Da, S: Aa, D: Ka, E: Za, m: eo, a: Wa, e: Va, o: qa, k: Ba, G: Qa, u: Ya, F: Xa, z: ro, O: ao, l: za, j: Ga, c: Ha, p: La, H: Ja, r: to, i: Na, y: no, N: Ma, Q: Ua }, H = nn(), ce = o._free = (e) => (ce = o._free = H.ha)(e), At = o._malloc = (e) => (At = o._malloc = H.ia)(e), hr = (e) => (hr = H.ka)(e);
    o.__embind_initialize_bindings = () => (o.__embind_initialize_bindings = H.la)();
    var B = (e, t) => (B = H.ma)(e, t), ke = (e) => (ke = H.na)(e), z = () => (z = H.oa)(), G = (e) => (G = H.pa)(e), pr = (e) => (pr = H.qa)(e), mr = (e) => (mr = H.ra)(e), vr = (e, t, n) => (vr = H.sa)(e, t, n), yr = (e) => (yr = H.ta)(e);
    o.dynCall_viijii = (e, t, n, i, s, u, d) => (o.dynCall_viijii = H.ua)(e, t, n, i, s, u, d);
    var gr = o.dynCall_jiiii = (e, t, n, i, s) => (gr = o.dynCall_jiiii = H.va)(e, t, n, i, s);
    o.dynCall_iiiiij = (e, t, n, i, s, u, d) => (o.dynCall_iiiiij = H.wa)(e, t, n, i, s, u, d), o.dynCall_iiiiijj = (e, t, n, i, s, u, d, f, m) => (o.dynCall_iiiiijj = H.xa)(e, t, n, i, s, u, d, f, m), o.dynCall_iiiiiijj = (e, t, n, i, s, u, d, f, m, w) => (o.dynCall_iiiiiijj = H.ya)(e, t, n, i, s, u, d, f, m, w);
    function Wa(e, t) {
      var n = z();
      try {
        return V(e)(t);
      } catch (i) {
        if (G(n), i !== i + 0)
          throw i;
        B(1, 0);
      }
    }
    function La(e, t, n, i) {
      var s = z();
      try {
        V(e)(t, n, i);
      } catch (u) {
        if (G(s), u !== u + 0)
          throw u;
        B(1, 0);
      }
    }
    function Ha(e, t, n) {
      var i = z();
      try {
        V(e)(t, n);
      } catch (s) {
        if (G(i), s !== s + 0)
          throw s;
        B(1, 0);
      }
    }
    function Ba(e, t, n, i, s) {
      var u = z();
      try {
        return V(e)(t, n, i, s);
      } catch (d) {
        if (G(u), d !== d + 0)
          throw d;
        B(1, 0);
      }
    }
    function Va(e, t, n) {
      var i = z();
      try {
        return V(e)(t, n);
      } catch (s) {
        if (G(i), s !== s + 0)
          throw s;
        B(1, 0);
      }
    }
    function za(e) {
      var t = z();
      try {
        V(e)();
      } catch (n) {
        if (G(t), n !== n + 0)
          throw n;
        B(1, 0);
      }
    }
    function Ga(e, t) {
      var n = z();
      try {
        V(e)(t);
      } catch (i) {
        if (G(n), i !== i + 0)
          throw i;
        B(1, 0);
      }
    }
    function qa(e, t, n, i) {
      var s = z();
      try {
        return V(e)(t, n, i);
      } catch (u) {
        if (G(s), u !== u + 0)
          throw u;
        B(1, 0);
      }
    }
    function Na(e, t, n, i, s, u, d, f, m, w, $) {
      var T = z();
      try {
        V(e)(t, n, i, s, u, d, f, m, w, $);
      } catch (E) {
        if (G(T), E !== E + 0)
          throw E;
        B(1, 0);
      }
    }
    function Ya(e, t, n, i, s, u, d) {
      var f = z();
      try {
        return V(e)(t, n, i, s, u, d);
      } catch (m) {
        if (G(f), m !== m + 0)
          throw m;
        B(1, 0);
      }
    }
    function Ja(e, t, n, i, s) {
      var u = z();
      try {
        V(e)(t, n, i, s);
      } catch (d) {
        if (G(u), d !== d + 0)
          throw d;
        B(1, 0);
      }
    }
    function Qa(e, t, n, i, s, u) {
      var d = z();
      try {
        return V(e)(t, n, i, s, u);
      } catch (f) {
        if (G(d), f !== f + 0)
          throw f;
        B(1, 0);
      }
    }
    function Xa(e, t, n, i, s, u, d, f) {
      var m = z();
      try {
        return V(e)(t, n, i, s, u, d, f);
      } catch (w) {
        if (G(m), w !== w + 0)
          throw w;
        B(1, 0);
      }
    }
    function Za(e, t, n, i) {
      var s = z();
      try {
        return V(e)(t, n, i);
      } catch (u) {
        if (G(s), u !== u + 0)
          throw u;
        B(1, 0);
      }
    }
    function Ka(e, t, n, i) {
      var s = z();
      try {
        return V(e)(t, n, i);
      } catch (u) {
        if (G(s), u !== u + 0)
          throw u;
        B(1, 0);
      }
    }
    function eo(e) {
      var t = z();
      try {
        return V(e)();
      } catch (n) {
        if (G(t), n !== n + 0)
          throw n;
        B(1, 0);
      }
    }
    function to(e, t, n, i, s, u, d, f) {
      var m = z();
      try {
        V(e)(t, n, i, s, u, d, f);
      } catch (w) {
        if (G(m), w !== w + 0)
          throw w;
        B(1, 0);
      }
    }
    function ro(e, t, n, i, s, u, d, f, m, w, $, T) {
      var E = z();
      try {
        return V(e)(t, n, i, s, u, d, f, m, w, $, T);
      } catch (D) {
        if (G(E), D !== D + 0)
          throw D;
        B(1, 0);
      }
    }
    function no(e, t, n, i, s, u, d, f, m, w, $, T, E, D, U, Q) {
      var j = z();
      try {
        V(e)(t, n, i, s, u, d, f, m, w, $, T, E, D, U, Q);
      } catch (X) {
        if (G(j), X !== X + 0)
          throw X;
        B(1, 0);
      }
    }
    function ao(e, t, n, i, s) {
      var u = z();
      try {
        return gr(e, t, n, i, s);
      } catch (d) {
        if (G(u), d !== d + 0)
          throw d;
        B(1, 0);
      }
    }
    var Ke;
    K = function e() {
      Ke || wr(), Ke || (K = e);
    };
    function wr() {
      if (ie > 0 || (ct(), ie > 0))
        return;
      function e() {
        Ke || (Ke = !0, o.calledRun = !0, !I && (ut(), c(o), o.onRuntimeInitialized && o.onRuntimeInitialized(), lt()));
      }
      o.setStatus ? (o.setStatus("Running..."), setTimeout(function() {
        setTimeout(function() {
          o.setStatus("");
        }, 1), e();
      }, 1)) : e();
    }
    if (o.preInit)
      for (typeof o.preInit == "function" && (o.preInit = [o.preInit]); o.preInit.length > 0; )
        o.preInit.pop()();
    return wr(), a.ready;
  };
})();
function Lo(r) {
  return Wt(
    it,
    r
  );
}
function xi(r) {
  return Uo(
    it,
    r
  );
}
async function Ho(r, a) {
  return jo(
    it,
    r,
    a
  );
}
async function Bo(r, a) {
  return Wo(
    it,
    r,
    a
  );
}
var Ie;
class st extends EventTarget {
  constructor(a = {}) {
    var o;
    super(), fo(this, Ie, void 0);
    try {
      const c = (o = a == null ? void 0 : a.formats) == null ? void 0 : o.filter(
        (l) => l !== "unknown"
      );
      if ((c == null ? void 0 : c.length) === 0)
        throw new TypeError("Hint option provided, but is empty.");
      c == null || c.forEach((l) => {
        if (!nt.has(l))
          throw new TypeError(
            `Failed to read the 'formats' property from 'BarcodeDetectorOptions': The provided value '${l}' is not a valid enum value of type BarcodeFormat.`
          );
      }), ho(this, Ie, c != null ? c : []), Lo().then((l) => {
        this.dispatchEvent(
          new CustomEvent("load", {
            detail: l
          })
        );
      }).catch((l) => {
        this.dispatchEvent(new CustomEvent("error", { detail: l }));
      });
    } catch (c) {
      throw Cr(
        c,
        "Failed to construct 'BarcodeDetector'"
      );
    }
  }
  static async getSupportedFormats() {
    return po.filter((a) => a !== "unknown");
  }
  async detect(a) {
    try {
      const o = await Co(a);
      if (o === null)
        return [];
      let c;
      try {
        jr(o) ? c = await Ho(o, {
          tryHarder: !0,
          formats: br(this, Ie).map((l) => nt.get(l))
        }) : c = await Bo(o, {
          tryHarder: !0,
          formats: br(this, Ie).map((l) => nt.get(l))
        });
      } catch (l) {
        throw console.error(l), new DOMException(
          "Barcode detection service unavailable.",
          "NotSupportedError"
        );
      }
      return c.map((l) => {
        const {
          topLeft: { x: h, y: v },
          topRight: { x: g, y: b },
          bottomLeft: { x: p, y: _ },
          bottomRight: { x: S, y: C }
        } = l.position, F = Math.min(h, g, p, S), k = Math.min(v, b, _, C), I = Math.max(h, g, p, S), L = Math.max(v, b, _, C);
        return {
          boundingBox: new DOMRectReadOnly(
            F,
            k,
            I - F,
            L - k
          ),
          rawValue: l.text,
          format: mo(l.format),
          cornerPoints: [
            {
              x: h,
              y: v
            },
            {
              x: g,
              y: b
            },
            {
              x: S,
              y: C
            },
            {
              x: p,
              y: _
            }
          ]
        };
      });
    } catch (o) {
      throw Cr(
        o,
        "Failed to execute 'detect' on 'BarcodeDetector'"
      );
    }
  }
}
Ie = /* @__PURE__ */ new WeakMap();
const Lt = (r, a, o = "error") => {
  let c, l;
  const h = new Promise(
    (v, g) => {
      c = v, l = g, r.addEventListener(a, c), r.addEventListener(o, l);
    }
  );
  return h.finally(() => {
    r.removeEventListener(a, c), r.removeEventListener(o, l);
  }), h;
}, Sr = (r) => new Promise((a) => setTimeout(a, r));
class Vo extends Error {
  constructor() {
    super("can't process cross-origin image"), this.name = "DropImageFetchError";
  }
}
class Br extends Error {
  constructor() {
    super("this browser has no Stream API support"), this.name = "StreamApiNotSupportedError";
  }
}
class zo extends Error {
  constructor() {
    super(
      "camera access is only permitted in secure context. Use HTTPS or localhost rather than HTTP."
    ), this.name = "InsecureContextError";
  }
}
class Go extends Error {
  constructor() {
    super(
      "Loading camera stream timed out after 3 seconds. If you are on iOS in PWA mode, this is a known issue (see https://github.com/gruhn/vue-qrcode-reader/issues/298)"
    ), this.name = "StreamLoadTimeoutError";
  }
}
let Ft;
const qo = (r) => {
  Ft = new st({ formats: r });
}, No = async (r, {
  detectHandler: a,
  locateHandler: o,
  minDelay: c,
  formats: l
}) => {
  Ft = new st({ formats: l });
  const h = (v) => async (g) => {
    if (r.readyState > 1) {
      const { lastScanned: b, contentBefore: p, lastScanHadContent: _ } = v;
      if (g - b < c)
        window.requestAnimationFrame(h(v));
      else {
        const S = await Ft.detect(r), C = S.some((I) => !p.includes(I.rawValue));
        C && a(S);
        const F = S.length > 0;
        F && o(S), !F && _ && o(S);
        const k = {
          lastScanned: g,
          lastScanHadContent: F,
          // It can happen that a QR code is constantly in view of the camera but
          // maybe a scanned frame is a bit blurry and we detect nothing but in the
          // next frame we detect the code again. We also want to avoid emitting
          // a `detect` event in such a case. So we don't reset `contentBefore`,
          // if we detect nothing, only if we detect something new.
          contentBefore: C ? S.map((I) => I.rawValue) : p
        };
        window.requestAnimationFrame(h(k));
      }
    }
  };
  h({
    lastScanned: performance.now(),
    contentBefore: [],
    lastScanHadContent: !1
  })(performance.now());
}, Yo = async (r) => {
  if (r.startsWith("http") && r.includes(location.host) === !1)
    throw new Vo();
  const a = document.createElement("img");
  return a.src = r, await Lt(a, "load"), a;
}, Vr = async (r, a = ["qr_code"]) => await new st({
  formats: a
}).detect(r), Jo = async (r, a = ["qr_code"]) => {
  const o = new st({
    formats: a
  }), c = await Yo(r);
  return await o.detect(c);
};
var zr = {}, Z = {};
Object.defineProperty(Z, "__esModule", {
  value: !0
});
Z.compactObject = Nr;
Z.deprecated = ai;
var Qo = Z.detectBrowser = oi;
Z.disableLog = ti;
Z.disableWarnings = ri;
Z.extractVersion = at;
Z.filterStats = ii;
Z.log = ni;
Z.walkStats = ot;
Z.wrapPeerConnectionEvent = ei;
function Xo(r, a, o) {
  return a = Zo(a), a in r ? Object.defineProperty(r, a, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : r[a] = o, r;
}
function Zo(r) {
  var a = Ko(r, "string");
  return he(a) === "symbol" ? a : String(a);
}
function Ko(r, a) {
  if (he(r) !== "object" || r === null)
    return r;
  var o = r[Symbol.toPrimitive];
  if (o !== void 0) {
    var c = o.call(r, a || "default");
    if (he(c) !== "object")
      return c;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (a === "string" ? String : Number)(r);
}
function he(r) {
  "@babel/helpers - typeof";
  return he = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
    return typeof a;
  } : function(a) {
    return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
  }, he(r);
}
var Gr = !0, qr = !0;
function at(r, a, o) {
  var c = r.match(a);
  return c && c.length >= o && parseInt(c[o], 10);
}
function ei(r, a, o) {
  if (r.RTCPeerConnection) {
    var c = r.RTCPeerConnection.prototype, l = c.addEventListener;
    c.addEventListener = function(v, g) {
      if (v !== a)
        return l.apply(this, arguments);
      var b = function(_) {
        var S = o(_);
        S && (g.handleEvent ? g.handleEvent(S) : g(S));
      };
      return this._eventMap = this._eventMap || {}, this._eventMap[a] || (this._eventMap[a] = /* @__PURE__ */ new Map()), this._eventMap[a].set(g, b), l.apply(this, [v, b]);
    };
    var h = c.removeEventListener;
    c.removeEventListener = function(v, g) {
      if (v !== a || !this._eventMap || !this._eventMap[a])
        return h.apply(this, arguments);
      if (!this._eventMap[a].has(g))
        return h.apply(this, arguments);
      var b = this._eventMap[a].get(g);
      return this._eventMap[a].delete(g), this._eventMap[a].size === 0 && delete this._eventMap[a], Object.keys(this._eventMap).length === 0 && delete this._eventMap, h.apply(this, [v, b]);
    }, Object.defineProperty(c, "on" + a, {
      get: function() {
        return this["_on" + a];
      },
      set: function(g) {
        this["_on" + a] && (this.removeEventListener(a, this["_on" + a]), delete this["_on" + a]), g && this.addEventListener(a, this["_on" + a] = g);
      },
      enumerable: !0,
      configurable: !0
    });
  }
}
function ti(r) {
  return typeof r != "boolean" ? new Error("Argument type: " + he(r) + ". Please use a boolean.") : (Gr = r, r ? "adapter.js logging disabled" : "adapter.js logging enabled");
}
function ri(r) {
  return typeof r != "boolean" ? new Error("Argument type: " + he(r) + ". Please use a boolean.") : (qr = !r, "adapter.js deprecation warnings " + (r ? "disabled" : "enabled"));
}
function ni() {
  if ((typeof window > "u" ? "undefined" : he(window)) === "object") {
    if (Gr)
      return;
    typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments);
  }
}
function ai(r, a) {
  qr && console.warn(r + " is deprecated, please use " + a + " instead.");
}
function oi(r) {
  var a = {
    browser: null,
    version: null
  };
  if (typeof r > "u" || !r.navigator || !r.navigator.userAgent)
    return a.browser = "Not a browser.", a;
  var o = r.navigator;
  if (o.mozGetUserMedia)
    a.browser = "firefox", a.version = at(o.userAgent, /Firefox\/(\d+)\./, 1);
  else if (o.webkitGetUserMedia || r.isSecureContext === !1 && r.webkitRTCPeerConnection)
    a.browser = "chrome", a.version = at(o.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  else if (r.RTCPeerConnection && o.userAgent.match(/AppleWebKit\/(\d+)\./))
    a.browser = "safari", a.version = at(o.userAgent, /AppleWebKit\/(\d+)\./, 1), a.supportsUnifiedPlan = r.RTCRtpTransceiver && "currentDirection" in r.RTCRtpTransceiver.prototype;
  else
    return a.browser = "Not a supported browser.", a;
  return a;
}
function Pr(r) {
  return Object.prototype.toString.call(r) === "[object Object]";
}
function Nr(r) {
  return Pr(r) ? Object.keys(r).reduce(function(a, o) {
    var c = Pr(r[o]), l = c ? Nr(r[o]) : r[o], h = c && !Object.keys(l).length;
    return l === void 0 || h ? a : Object.assign(a, Xo({}, o, l));
  }, {}) : r;
}
function ot(r, a, o) {
  !a || o.has(a.id) || (o.set(a.id, a), Object.keys(a).forEach(function(c) {
    c.endsWith("Id") ? ot(r, r.get(a[c]), o) : c.endsWith("Ids") && a[c].forEach(function(l) {
      ot(r, r.get(l), o);
    });
  }));
}
function ii(r, a, o) {
  var c = o ? "outbound-rtp" : "inbound-rtp", l = /* @__PURE__ */ new Map();
  if (a === null)
    return l;
  var h = [];
  return r.forEach(function(v) {
    v.type === "track" && v.trackIdentifier === a.id && h.push(v);
  }), h.forEach(function(v) {
    r.forEach(function(g) {
      g.type === c && g.trackId === v.id && ot(r, g, l);
    });
  }), l;
}
Object.defineProperty(zr, "__esModule", {
  value: !0
});
var si = zr.shimGetUserMedia = li, ci = ui(Z);
function Yr(r) {
  if (typeof WeakMap != "function")
    return null;
  var a = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new WeakMap();
  return (Yr = function(l) {
    return l ? o : a;
  })(r);
}
function ui(r, a) {
  if (!a && r && r.__esModule)
    return r;
  if (r === null || fe(r) !== "object" && typeof r != "function")
    return { default: r };
  var o = Yr(a);
  if (o && o.has(r))
    return o.get(r);
  var c = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var h in r)
    if (h !== "default" && Object.prototype.hasOwnProperty.call(r, h)) {
      var v = l ? Object.getOwnPropertyDescriptor(r, h) : null;
      v && (v.get || v.set) ? Object.defineProperty(c, h, v) : c[h] = r[h];
    }
  return c.default = r, o && o.set(r, c), c;
}
function fe(r) {
  "@babel/helpers - typeof";
  return fe = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
    return typeof a;
  } : function(a) {
    return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
  }, fe(r);
}
var Tr = ci.log;
function li(r, a) {
  var o = r && r.navigator;
  if (o.mediaDevices) {
    var c = function(p) {
      if (fe(p) !== "object" || p.mandatory || p.optional)
        return p;
      var _ = {};
      return Object.keys(p).forEach(function(S) {
        if (!(S === "require" || S === "advanced" || S === "mediaSource")) {
          var C = fe(p[S]) === "object" ? p[S] : {
            ideal: p[S]
          };
          C.exact !== void 0 && typeof C.exact == "number" && (C.min = C.max = C.exact);
          var F = function(L, R) {
            return L ? L + R.charAt(0).toUpperCase() + R.slice(1) : R === "deviceId" ? "sourceId" : R;
          };
          if (C.ideal !== void 0) {
            _.optional = _.optional || [];
            var k = {};
            typeof C.ideal == "number" ? (k[F("min", S)] = C.ideal, _.optional.push(k), k = {}, k[F("max", S)] = C.ideal, _.optional.push(k)) : (k[F("", S)] = C.ideal, _.optional.push(k));
          }
          C.exact !== void 0 && typeof C.exact != "number" ? (_.mandatory = _.mandatory || {}, _.mandatory[F("", S)] = C.exact) : ["min", "max"].forEach(function(I) {
            C[I] !== void 0 && (_.mandatory = _.mandatory || {}, _.mandatory[F(I, S)] = C[I]);
          });
        }
      }), p.advanced && (_.optional = (_.optional || []).concat(p.advanced)), _;
    }, l = function(p, _) {
      if (a.version >= 61)
        return _(p);
      if (p = JSON.parse(JSON.stringify(p)), p && fe(p.audio) === "object") {
        var S = function(L, R, O) {
          R in L && !(O in L) && (L[O] = L[R], delete L[R]);
        };
        p = JSON.parse(JSON.stringify(p)), S(p.audio, "autoGainControl", "googAutoGainControl"), S(p.audio, "noiseSuppression", "googNoiseSuppression"), p.audio = c(p.audio);
      }
      if (p && fe(p.video) === "object") {
        var C = p.video.facingMode;
        C = C && (fe(C) === "object" ? C : {
          ideal: C
        });
        var F = a.version < 66;
        if (C && (C.exact === "user" || C.exact === "environment" || C.ideal === "user" || C.ideal === "environment") && !(o.mediaDevices.getSupportedConstraints && o.mediaDevices.getSupportedConstraints().facingMode && !F)) {
          delete p.video.facingMode;
          var k;
          if (C.exact === "environment" || C.ideal === "environment" ? k = ["back", "rear"] : (C.exact === "user" || C.ideal === "user") && (k = ["front"]), k)
            return o.mediaDevices.enumerateDevices().then(function(I) {
              I = I.filter(function(R) {
                return R.kind === "videoinput";
              });
              var L = I.find(function(R) {
                return k.some(function(O) {
                  return R.label.toLowerCase().includes(O);
                });
              });
              return !L && I.length && k.includes("back") && (L = I[I.length - 1]), L && (p.video.deviceId = C.exact ? {
                exact: L.deviceId
              } : {
                ideal: L.deviceId
              }), p.video = c(p.video), Tr("chrome: " + JSON.stringify(p)), _(p);
            });
        }
        p.video = c(p.video);
      }
      return Tr("chrome: " + JSON.stringify(p)), _(p);
    }, h = function(p) {
      return a.version >= 64 ? p : {
        name: {
          PermissionDeniedError: "NotAllowedError",
          PermissionDismissedError: "NotAllowedError",
          InvalidStateError: "NotAllowedError",
          DevicesNotFoundError: "NotFoundError",
          ConstraintNotSatisfiedError: "OverconstrainedError",
          TrackStartError: "NotReadableError",
          MediaDeviceFailedDueToShutdown: "NotAllowedError",
          MediaDeviceKillSwitchOn: "NotAllowedError",
          TabCaptureError: "AbortError",
          ScreenCaptureError: "AbortError",
          DeviceCaptureError: "AbortError"
        }[p.name] || p.name,
        message: p.message,
        constraint: p.constraint || p.constraintName,
        toString: function() {
          return this.name + (this.message && ": ") + this.message;
        }
      };
    }, v = function(p, _, S) {
      l(p, function(C) {
        o.webkitGetUserMedia(C, _, function(F) {
          S && S(h(F));
        });
      });
    };
    if (o.getUserMedia = v.bind(o), o.mediaDevices.getUserMedia) {
      var g = o.mediaDevices.getUserMedia.bind(o.mediaDevices);
      o.mediaDevices.getUserMedia = function(b) {
        return l(b, function(p) {
          return g(p).then(function(_) {
            if (p.audio && !_.getAudioTracks().length || p.video && !_.getVideoTracks().length)
              throw _.getTracks().forEach(function(S) {
                S.stop();
              }), new DOMException("", "NotFoundError");
            return _;
          }, function(_) {
            return Promise.reject(h(_));
          });
        });
      };
    }
  }
}
var Jr = {};
Object.defineProperty(Jr, "__esModule", {
  value: !0
});
var di = Jr.shimGetUserMedia = pi, fi = hi(Z);
function Qr(r) {
  if (typeof WeakMap != "function")
    return null;
  var a = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new WeakMap();
  return (Qr = function(l) {
    return l ? o : a;
  })(r);
}
function hi(r, a) {
  if (!a && r && r.__esModule)
    return r;
  if (r === null || $e(r) !== "object" && typeof r != "function")
    return { default: r };
  var o = Qr(a);
  if (o && o.has(r))
    return o.get(r);
  var c = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var h in r)
    if (h !== "default" && Object.prototype.hasOwnProperty.call(r, h)) {
      var v = l ? Object.getOwnPropertyDescriptor(r, h) : null;
      v && (v.get || v.set) ? Object.defineProperty(c, h, v) : c[h] = r[h];
    }
  return c.default = r, o && o.set(r, c), c;
}
function $e(r) {
  "@babel/helpers - typeof";
  return $e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
    return typeof a;
  } : function(a) {
    return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
  }, $e(r);
}
function pi(r, a) {
  var o = r && r.navigator, c = r && r.MediaStreamTrack;
  if (o.getUserMedia = function(b, p, _) {
    fi.deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), o.mediaDevices.getUserMedia(b).then(p, _);
  }, !(a.version > 55 && "autoGainControl" in o.mediaDevices.getSupportedConstraints())) {
    var l = function(p, _, S) {
      _ in p && !(S in p) && (p[S] = p[_], delete p[_]);
    }, h = o.mediaDevices.getUserMedia.bind(o.mediaDevices);
    if (o.mediaDevices.getUserMedia = function(b) {
      return $e(b) === "object" && $e(b.audio) === "object" && (b = JSON.parse(JSON.stringify(b)), l(b.audio, "autoGainControl", "mozAutoGainControl"), l(b.audio, "noiseSuppression", "mozNoiseSuppression")), h(b);
    }, c && c.prototype.getSettings) {
      var v = c.prototype.getSettings;
      c.prototype.getSettings = function() {
        var b = v.apply(this, arguments);
        return l(b, "mozAutoGainControl", "autoGainControl"), l(b, "mozNoiseSuppression", "noiseSuppression"), b;
      };
    }
    if (c && c.prototype.applyConstraints) {
      var g = c.prototype.applyConstraints;
      c.prototype.applyConstraints = function(b) {
        return this.kind === "audio" && $e(b) === "object" && (b = JSON.parse(JSON.stringify(b)), l(b, "autoGainControl", "mozAutoGainControl"), l(b, "noiseSuppression", "mozNoiseSuppression")), g.apply(this, [b]);
      };
    }
  }
}
var oe = {};
Object.defineProperty(oe, "__esModule", {
  value: !0
});
oe.shimAudioContext = Si;
oe.shimCallbacksAPI = wi;
oe.shimConstraints = Kr;
oe.shimCreateOfferLegacy = $i;
var mi = oe.shimGetUserMedia = bi;
oe.shimLocalStreamsAPI = yi;
oe.shimRTCIceServerUrls = Ci;
oe.shimRemoteStreamsAPI = gi;
oe.shimTrackEventTransceiver = _i;
var Xr = vi(Z);
function Zr(r) {
  if (typeof WeakMap != "function")
    return null;
  var a = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new WeakMap();
  return (Zr = function(l) {
    return l ? o : a;
  })(r);
}
function vi(r, a) {
  if (!a && r && r.__esModule)
    return r;
  if (r === null || pe(r) !== "object" && typeof r != "function")
    return { default: r };
  var o = Zr(a);
  if (o && o.has(r))
    return o.get(r);
  var c = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var h in r)
    if (h !== "default" && Object.prototype.hasOwnProperty.call(r, h)) {
      var v = l ? Object.getOwnPropertyDescriptor(r, h) : null;
      v && (v.get || v.set) ? Object.defineProperty(c, h, v) : c[h] = r[h];
    }
  return c.default = r, o && o.set(r, c), c;
}
function pe(r) {
  "@babel/helpers - typeof";
  return pe = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
    return typeof a;
  } : function(a) {
    return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
  }, pe(r);
}
function yi(r) {
  if (!(pe(r) !== "object" || !r.RTCPeerConnection)) {
    if ("getLocalStreams" in r.RTCPeerConnection.prototype || (r.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this._localStreams || (this._localStreams = []), this._localStreams;
    }), !("addStream" in r.RTCPeerConnection.prototype)) {
      var a = r.RTCPeerConnection.prototype.addTrack;
      r.RTCPeerConnection.prototype.addStream = function(c) {
        var l = this;
        this._localStreams || (this._localStreams = []), this._localStreams.includes(c) || this._localStreams.push(c), c.getAudioTracks().forEach(function(h) {
          return a.call(l, h, c);
        }), c.getVideoTracks().forEach(function(h) {
          return a.call(l, h, c);
        });
      }, r.RTCPeerConnection.prototype.addTrack = function(c) {
        for (var l = this, h = arguments.length, v = new Array(h > 1 ? h - 1 : 0), g = 1; g < h; g++)
          v[g - 1] = arguments[g];
        return v && v.forEach(function(b) {
          l._localStreams ? l._localStreams.includes(b) || l._localStreams.push(b) : l._localStreams = [b];
        }), a.apply(this, arguments);
      };
    }
    "removeStream" in r.RTCPeerConnection.prototype || (r.RTCPeerConnection.prototype.removeStream = function(c) {
      var l = this;
      this._localStreams || (this._localStreams = []);
      var h = this._localStreams.indexOf(c);
      if (h !== -1) {
        this._localStreams.splice(h, 1);
        var v = c.getTracks();
        this.getSenders().forEach(function(g) {
          v.includes(g.track) && l.removeTrack(g);
        });
      }
    });
  }
}
function gi(r) {
  if (!(pe(r) !== "object" || !r.RTCPeerConnection) && ("getRemoteStreams" in r.RTCPeerConnection.prototype || (r.RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this._remoteStreams ? this._remoteStreams : [];
  }), !("onaddstream" in r.RTCPeerConnection.prototype))) {
    Object.defineProperty(r.RTCPeerConnection.prototype, "onaddstream", {
      get: function() {
        return this._onaddstream;
      },
      set: function(c) {
        var l = this;
        this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = c), this.addEventListener("track", this._onaddstreampoly = function(h) {
          h.streams.forEach(function(v) {
            if (l._remoteStreams || (l._remoteStreams = []), !l._remoteStreams.includes(v)) {
              l._remoteStreams.push(v);
              var g = new Event("addstream");
              g.stream = v, l.dispatchEvent(g);
            }
          });
        });
      }
    });
    var a = r.RTCPeerConnection.prototype.setRemoteDescription;
    r.RTCPeerConnection.prototype.setRemoteDescription = function() {
      var c = this;
      return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(l) {
        l.streams.forEach(function(h) {
          if (c._remoteStreams || (c._remoteStreams = []), !(c._remoteStreams.indexOf(h) >= 0)) {
            c._remoteStreams.push(h);
            var v = new Event("addstream");
            v.stream = h, c.dispatchEvent(v);
          }
        });
      }), a.apply(c, arguments);
    };
  }
}
function wi(r) {
  if (!(pe(r) !== "object" || !r.RTCPeerConnection)) {
    var a = r.RTCPeerConnection.prototype, o = a.createOffer, c = a.createAnswer, l = a.setLocalDescription, h = a.setRemoteDescription, v = a.addIceCandidate;
    a.createOffer = function(p, _) {
      var S = arguments.length >= 2 ? arguments[2] : arguments[0], C = o.apply(this, [S]);
      return _ ? (C.then(p, _), Promise.resolve()) : C;
    }, a.createAnswer = function(p, _) {
      var S = arguments.length >= 2 ? arguments[2] : arguments[0], C = c.apply(this, [S]);
      return _ ? (C.then(p, _), Promise.resolve()) : C;
    };
    var g = function(p, _, S) {
      var C = l.apply(this, [p]);
      return S ? (C.then(_, S), Promise.resolve()) : C;
    };
    a.setLocalDescription = g, g = function(p, _, S) {
      var C = h.apply(this, [p]);
      return S ? (C.then(_, S), Promise.resolve()) : C;
    }, a.setRemoteDescription = g, g = function(p, _, S) {
      var C = v.apply(this, [p]);
      return S ? (C.then(_, S), Promise.resolve()) : C;
    }, a.addIceCandidate = g;
  }
}
function bi(r) {
  var a = r && r.navigator;
  if (a.mediaDevices && a.mediaDevices.getUserMedia) {
    var o = a.mediaDevices, c = o.getUserMedia.bind(o);
    a.mediaDevices.getUserMedia = function(l) {
      return c(Kr(l));
    };
  }
  !a.getUserMedia && a.mediaDevices && a.mediaDevices.getUserMedia && (a.getUserMedia = (function(h, v, g) {
    a.mediaDevices.getUserMedia(h).then(v, g);
  }).bind(a));
}
function Kr(r) {
  return r && r.video !== void 0 ? Object.assign({}, r, {
    video: Xr.compactObject(r.video)
  }) : r;
}
function Ci(r) {
  if (r.RTCPeerConnection) {
    var a = r.RTCPeerConnection;
    r.RTCPeerConnection = function(c, l) {
      if (c && c.iceServers) {
        for (var h = [], v = 0; v < c.iceServers.length; v++) {
          var g = c.iceServers[v];
          g.urls === void 0 && g.url ? (Xr.deprecated("RTCIceServer.url", "RTCIceServer.urls"), g = JSON.parse(JSON.stringify(g)), g.urls = g.url, delete g.url, h.push(g)) : h.push(c.iceServers[v]);
        }
        c.iceServers = h;
      }
      return new a(c, l);
    }, r.RTCPeerConnection.prototype = a.prototype, "generateCertificate" in a && Object.defineProperty(r.RTCPeerConnection, "generateCertificate", {
      get: function() {
        return a.generateCertificate;
      }
    });
  }
}
function _i(r) {
  pe(r) === "object" && r.RTCTrackEvent && "receiver" in r.RTCTrackEvent.prototype && !("transceiver" in r.RTCTrackEvent.prototype) && Object.defineProperty(r.RTCTrackEvent.prototype, "transceiver", {
    get: function() {
      return {
        receiver: this.receiver
      };
    }
  });
}
function $i(r) {
  var a = r.RTCPeerConnection.prototype.createOffer;
  r.RTCPeerConnection.prototype.createOffer = function(c) {
    if (c) {
      typeof c.offerToReceiveAudio < "u" && (c.offerToReceiveAudio = !!c.offerToReceiveAudio);
      var l = this.getTransceivers().find(function(v) {
        return v.receiver.track.kind === "audio";
      });
      c.offerToReceiveAudio === !1 && l ? l.direction === "sendrecv" ? l.setDirection ? l.setDirection("sendonly") : l.direction = "sendonly" : l.direction === "recvonly" && (l.setDirection ? l.setDirection("inactive") : l.direction = "inactive") : c.offerToReceiveAudio === !0 && !l && this.addTransceiver("audio", {
        direction: "recvonly"
      }), typeof c.offerToReceiveVideo < "u" && (c.offerToReceiveVideo = !!c.offerToReceiveVideo);
      var h = this.getTransceivers().find(function(v) {
        return v.receiver.track.kind === "video";
      });
      c.offerToReceiveVideo === !1 && h ? h.direction === "sendrecv" ? h.setDirection ? h.setDirection("sendonly") : h.direction = "sendonly" : h.direction === "recvonly" && (h.setDirection ? h.setDirection("inactive") : h.direction = "inactive") : c.offerToReceiveVideo === !0 && !h && this.addTransceiver("video", {
        direction: "recvonly"
      });
    }
    return a.apply(this, arguments);
  };
}
function Si(r) {
  pe(r) !== "object" || r.AudioContext || (r.AudioContext = r.webkitAudioContext);
}
const Pi = (r) => {
  let a = !1, o;
  return (...c) => (a || (o = r(c), a = !0), o);
};
function ue(r, a) {
  if (r === !1)
    throw new Error(a != null ? a : "assertion failure");
}
const Ti = Pi(() => {
  const r = Qo(window);
  switch (r.browser) {
    case "chrome":
      si(window, r);
      break;
    case "firefox":
      di(window, r);
      break;
    case "safari":
      mi(window, r);
      break;
    default:
      throw new Br();
  }
});
let Se = Promise.resolve({ type: "stop", data: {} });
async function Er(r, a, o) {
  var g, b, p;
  if (window.isSecureContext !== !0)
    throw new zo();
  if (((g = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : g.getUserMedia) === void 0)
    throw new Br();
  Ti();
  const c = await navigator.mediaDevices.getUserMedia({
    audio: !1,
    video: a
  });
  r.srcObject !== void 0 ? r.srcObject = c : r.mozSrcObject !== void 0 ? r.mozSrcObject = c : window.URL.createObjectURL ? r.src = window.URL.createObjectURL(c) : window.webkitURL ? r.src = window.webkitURL.createObjectURL(c) : r.src = c.id, r.play(), await Promise.race([
    Lt(r, "loadeddata"),
    // On iOS devices in PWA mode, QrcodeStream works initially, but after
    // killing and restarting the PWA, all video elements fail to load camera
    // streams and never emit the `loadeddata` event. Looks like this is
    // related to a WebKit issue (see #298). No workarounds at the moment.
    // To at least detect this situation, we throw an error if the event
    // has not been emitted after a 3 second timeout.
    Sr(3e3).then(() => {
      throw new Go();
    })
  ]), await Sr(500);
  const [l] = c.getVideoTracks(), h = (p = (b = l == null ? void 0 : l.getCapabilities) == null ? void 0 : b.call(l)) != null ? p : {};
  let v = !1;
  return o && h.torch && (await l.applyConstraints({ advanced: [{ torch: !0 }] }), v = !0), {
    type: "start",
    data: {
      videoEl: r,
      stream: c,
      capabilities: h,
      constraints: a,
      isTorchOn: v
    }
  };
}
async function Ei(r, {
  constraints: a,
  torch: o,
  restart: c = !1
}) {
  Se = Se.then((h) => {
    if (h.type === "start") {
      const {
        data: {
          videoEl: v,
          stream: g,
          constraints: b,
          isTorchOn: p
        }
      } = h;
      return !c && r === v && a === b && o === p ? h : en(v, g, p).then(
        () => Er(r, a, o)
      );
    }
    return Er(r, a, o);
  });
  const l = await Se;
  if (l.type === "stop")
    throw new Error("Something went wrong with the camera task queue (start task).");
  return l.data.capabilities;
}
async function en(r, a, o) {
  r.src = "", r.srcObject = null, r.load(), await Lt(r, "error");
  for (const c of a.getTracks())
    o != null || await c.applyConstraints({ advanced: [{ torch: !1 }] }), a.removeTrack(c), c.stop();
  return {
    type: "stop",
    data: {}
  };
}
async function xt() {
  if (Se = Se.then((a) => {
    if (a.type === "stop")
      return a;
    const {
      data: { videoEl: o, stream: c, isTorchOn: l }
    } = a;
    return en(o, c, l);
  }), (await Se).type === "start")
    throw new Error("Something went wrong with the camera task queue (stop task).");
}
const Oi = /* @__PURE__ */ It({
  __name: "QrcodeStream",
  props: {
    constraints: {
      type: Object,
      default() {
        return { facingMode: "environment" };
      }
    },
    formats: {
      type: Array,
      default: () => ["qr_code"]
    },
    paused: {
      type: Boolean,
      default: !1
    },
    torch: {
      type: Boolean,
      default: !1
    },
    track: {
      type: Function
    }
  },
  emits: ["detect", "camera-on", "camera-off", "error"],
  setup(r, { emit: a }) {
    const o = r, c = a, l = Fe(), h = Fe(), v = Fe(), g = Fe(!1), b = Fe(!1);
    oo(() => {
      b.value = !0;
    }), io(() => {
      xt();
    });
    const p = Mt(() => ({
      torch: o.torch,
      constraints: o.constraints,
      shouldStream: b.value && !o.paused
    }));
    Rt(
      p,
      async (O) => {
        const x = v.value;
        ue(
          x !== void 0,
          "cameraSettings watcher should never be triggered when component is not mounted. Thus video element should always be defined."
        );
        const N = l.value;
        ue(
          N !== void 0,
          "cameraSettings watcher should never be triggered when component is not mounted. Thus canvas should always be defined."
        );
        const W = N.getContext("2d");
        if (ue(W !== null, "if cavnas is defined, canvas 2d context should also be non-null"), O.shouldStream)
          try {
            const M = await Ei(x, O);
            b.value ? (g.value = !0, c("camera-on", M)) : await xt();
          } catch (M) {
            c("error", M);
          }
        else
          N.width = x.videoWidth, N.height = x.videoHeight, W.drawImage(x, 0, 0, x.videoWidth, x.videoHeight), xt(), g.value = !1, c("camera-off");
      },
      { deep: !0 }
    );
    const { formats: _ } = so(o);
    Rt(_, (O) => {
      b.value && qo(O);
    });
    const S = Mt(() => p.value.shouldStream && g.value);
    Rt(S, (O) => {
      if (O) {
        ue(
          l.value !== void 0,
          "shouldScan watcher should only be triggered when component is mounted. Thus pause frame canvas is defined"
        ), C(l.value), ue(
          h.value !== void 0,
          "shouldScan watcher should only be triggered when component is mounted. Thus tracking canvas is defined"
        ), C(h.value);
        const x = () => o.track === void 0 ? 500 : 40;
        ue(
          v.value !== void 0,
          "shouldScan watcher should only be triggered when component is mounted. Thus video element is defined"
        ), No(v.value, {
          detectHandler: (N) => c("detect", N),
          formats: o.formats,
          locateHandler: F,
          minDelay: x()
        });
      }
    });
    const C = (O) => {
      const x = O.getContext("2d");
      ue(x !== null, "canvas 2d context should always be non-null"), x.clearRect(0, 0, O.width, O.height);
    }, F = (O) => {
      const x = h.value;
      ue(
        x !== void 0,
        "onLocate handler should only be called when component is mounted. Thus tracking canvas is always defined."
      );
      const N = v.value;
      if (ue(
        N !== void 0,
        "onLocate handler should only be called when component is mounted. Thus video element is always defined."
      ), O.length === 0 || o.track === void 0)
        C(x);
      else {
        const W = N.offsetWidth, M = N.offsetHeight, we = N.videoWidth, be = N.videoHeight, Pe = Math.max(W / we, M / be), Te = we * Pe, Ee = be * Pe, je = Te / we, ct = Ee / be, ut = (W - Te) / 2, lt = (M - Ee) / 2, Oe = ({ x: K, y: re }) => ({
          x: Math.floor(K * je),
          y: Math.floor(re * ct)
        }), We = ({ x: K, y: re }) => ({
          x: Math.floor(K + ut),
          y: Math.floor(re + lt)
        }), dt = O.map((K) => {
          const { boundingBox: re, cornerPoints: ft } = K, { x: me, y: ht } = We(
            Oe({
              x: re.x,
              y: re.y
            })
          ), { x: Le, y: le } = Oe({
            x: re.width,
            y: re.height
          });
          return {
            ...K,
            cornerPoints: ft.map((He) => We(Oe(He))),
            boundingBox: DOMRectReadOnly.fromRect({ x: me, y: ht, width: Le, height: le })
          };
        });
        x.width = N.offsetWidth, x.height = N.offsetHeight;
        const ie = x.getContext("2d");
        o.track(dt, ie);
      }
    }, k = {
      width: "100%",
      height: "100%",
      position: "relative",
      // notice that we use z-index only once for the wrapper div.
      // If z-index is not defined, elements are stacked in the order they appear in the DOM.
      // The first element is at the very bottom and subsequent elements are added on top.
      "z-index": "0"
    }, I = {
      width: "100%",
      height: "100%",
      position: "absolute",
      top: "0",
      left: "0"
    }, L = {
      width: "100%",
      height: "100%",
      "object-fit": "cover"
    }, R = Mt(() => S.value ? L : {
      ...L,
      visibility: "hidden",
      position: "absolute"
    });
    return (O, x) => (Ut(), jt("div", { style: k }, [
      tt("video", {
        ref_key: "videoRef",
        ref: v,
        style: co(R.value),
        autoplay: "",
        muted: "",
        playsinline: ""
      }, null, 4),
      uo(tt("canvas", {
        id: "qrcode-stream-pause-frame",
        ref_key: "pauseFrameRef",
        ref: l,
        style: L
      }, null, 512), [
        [lo, !S.value]
      ]),
      tt("canvas", {
        id: "qrcode-stream-tracking-layer",
        ref_key: "trackingLayerRef",
        ref: h,
        style: I
      }, null, 512),
      tt("div", { style: I }, [
        Or(O.$slots, "default")
      ])
    ]));
  }
}), Di = /* @__PURE__ */ It({
  __name: "QrcodeCapture",
  props: {
    formats: {
      type: Array,
      default: () => ["qr_code"]
    }
  },
  emits: ["detect"],
  setup(r, { emit: a }) {
    const o = r, c = a, l = (h) => {
      if (!(!(h.target instanceof HTMLInputElement) || !h.target.files))
        for (const v of Array.from(h.target.files))
          Vr(v, o.formats).then((g) => {
            c("detect", g);
          });
    };
    return (h, v) => (Ut(), jt("input", {
      onChange: l,
      type: "file",
      name: "image",
      accept: "image/*",
      capture: "environment",
      multiple: ""
    }, null, 32));
  }
}), Ai = /* @__PURE__ */ It({
  __name: "QrcodeDropZone",
  props: {
    formats: {
      type: Array,
      default: () => ["qr_code"]
    }
  },
  emits: ["detect", "dragover", "error"],
  setup(r, { emit: a }) {
    const o = r, c = a, l = async (g) => {
      try {
        const b = await g;
        c("detect", b);
      } catch (b) {
        c("error", b);
      }
    }, h = (g) => {
      c("dragover", g);
    }, v = ({ dataTransfer: g }) => {
      if (!g)
        return;
      h(!1);
      const b = [...Array.from(g.files)], p = g.getData("text/uri-list");
      b.forEach((_) => {
        l(Vr(_));
      }), p !== "" && l(Jo(p, o.formats));
    };
    return (g, b) => (Ut(), jt("div", {
      onDrop: rt(v, ["prevent", "stop"]),
      onDragenter: b[0] || (b[0] = rt((p) => h(!0), ["prevent", "stop"])),
      onDragleave: b[1] || (b[1] = rt((p) => h(!1), ["prevent", "stop"])),
      onDragover: b[2] || (b[2] = rt(() => {
      }, ["prevent", "stop"]))
    }, [
      Or(g.$slots, "default")
    ], 32));
  }
});
function Mi(r) {
  r.component("qrcode-stream", Oi), r.component("qrcode-capture", Di), r.component("qrcode-drop-zone", Ai);
}
const ki = { install: Mi };
export {
  Di as QrcodeCapture,
  Ai as QrcodeDropZone,
  Oi as QrcodeStream,
  ki as VueQrcodeReader,
  Mi as install,
  xi as setZXingModuleOverrides
};
